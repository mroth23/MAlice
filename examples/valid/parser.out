Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> root
Rule 1     root -> decls
Rule 2     decls -> decls decl
Rule 3     decls -> decl
Rule 4     decl -> varDecl
Rule 5     decl -> funcDecl
Rule 6     decl -> procDecl
Rule 7     varDecl -> ID WAS A type terminator
Rule 8     varDecl -> ID WAS A type TOO terminator
Rule 9     varDecl -> ID WAS A type OF expr terminator
Rule 10    varDecl -> ID HAD expr type terminator
Rule 11    funcDecl -> THE ROOM ID formalParams CONTAINED A type body
Rule 12    procDecl -> THE LOOKING - GLASS ID formalParams body
Rule 13    formalParams -> ( )
Rule 14    formalParams -> ( formalParamsList )
Rule 15    formalParamsList -> formalParam
Rule 16    formalParamsList -> formalParamsList , formalParam
Rule 17    formalParam -> type ID
Rule 18    formalParam -> refType ID
Rule 19    body -> OPENED decls compoundStmt CLOSED
Rule 20    body -> OPENED compoundStmt CLOSED
Rule 21    body -> OPENED CLOSED
Rule 22    compoundStmt -> compoundStmt stmt
Rule 23    compoundStmt -> stmt
Rule 24    stmt -> body
Rule 25    stmt -> .
Rule 26    stmt -> expr BECAME expr terminator
Rule 27    stmt -> expr ATE terminator
Rule 28    stmt -> expr DRANK terminator
Rule 29    stmt -> ALICE FOUND expr .
Rule 30    stmt -> expr SPOKE terminator
Rule 31    stmt -> expr SAID ALICE terminator
Rule 32    stmt -> WHAT WAS expr ?
Rule 33    stmt -> ID actualParams terminator
Rule 34    stmt -> EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES
Rule 35    stmt -> EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
Rule 36    stmt -> conditionalStmt BECAUSE ALICE WAS UNSURE WHICH
Rule 37    stmt -> conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
Rule 38    conditionalStmt -> PERHAPS ( expr ) SO compoundStmt
Rule 39    conditionalStmt -> conditionalStmt OR MAYBE ( expr ) SO compoundStmt
Rule 40    type -> NUMBER
Rule 41    type -> LETTER
Rule 42    type -> SENTENCE
Rule 43    refType -> SPIDER type
Rule 44    expr -> expr + expr
Rule 45    expr -> expr - expr
Rule 46    expr -> expr * expr
Rule 47    expr -> expr / expr
Rule 48    expr -> expr % expr
Rule 49    expr -> expr & expr
Rule 50    expr -> expr | expr
Rule 51    expr -> expr ^ expr
Rule 52    expr -> expr LOGICAL_OR expr
Rule 53    expr -> expr LOGICAL_AND expr
Rule 54    expr -> expr GREATER_THAN expr
Rule 55    expr -> expr LESS_THAN expr
Rule 56    expr -> expr GREATER_EQUAL expr
Rule 57    expr -> expr LESS_EQUAL expr
Rule 58    expr -> expr EQUAL expr
Rule 59    expr -> expr NOT_EQUAL expr
Rule 60    expr -> LOGICAL_NOT expr
Rule 61    expr -> ~ expr
Rule 62    expr -> + expr
Rule 63    expr -> - expr
Rule 64    expr -> ID
Rule 65    expr -> ID APOSTROPHE S expr PIECE
Rule 66    expr -> STRING_LITERAL
Rule 67    expr -> CHAR_LITERAL
Rule 68    expr -> INT_LITERAL
Rule 69    expr -> ( expr )
Rule 70    expr -> ID actualParams
Rule 71    actualParams -> ( actualParamsList )
Rule 72    actualParams -> ( )
Rule 73    actualParamsList -> expr
Rule 74    actualParamsList -> actualParamsList , expr
Rule 75    terminator -> .
Rule 76    terminator -> ,
Rule 77    terminator -> AND
Rule 78    terminator -> BUT
Rule 79    terminator -> THEN

Terminals, with rules where they appear

%                    : 48
&                    : 49
(                    : 13 14 34 35 38 39 69 71 72
)                    : 13 14 34 35 38 39 69 71 72
*                    : 46
+                    : 44 62
,                    : 16 74 76
-                    : 12 45 63
.                    : 25 29 75
/                    : 47
?                    : 32
A                    : 7 8 9 11
ALICE                : 29 31 35 36 37
AND                  : 77
APOSTROPHE           : 65
ATE                  : 27
BECAME               : 26
BECAUSE              : 34 35 36 37
BUT                  : 78
CHAR_LITERAL         : 67
CLOSED               : 19 20 21
CONTAINED            : 11
DRANK                : 28
EITHER               : 35
ENOUGH               : 34
EQUAL                : 58
EVENTUALLY           : 34
FOUND                : 29
GLASS                : 12
GREATER_EQUAL        : 56
GREATER_THAN         : 54
HAD                  : 10
ID                   : 7 8 9 10 11 12 17 18 33 64 65 70
INT_LITERAL          : 68
LESS_EQUAL           : 57
LESS_THAN            : 55
LETTER               : 41
LOGICAL_AND          : 53
LOGICAL_NOT          : 60
LOGICAL_OR           : 52
LOOKING              : 12
MAYBE                : 39
NOT_EQUAL            : 59
NUMBER               : 40
OF                   : 9
OPENED               : 19 20 21
OR                   : 35 37 39
PERHAPS              : 38
PIECE                : 65
ROOM                 : 11
S                    : 65
SAID                 : 31
SENTENCE             : 42
SO                   : 35 38 39
SPIDER               : 43
SPOKE                : 30
STRING_LITERAL       : 66
THE                  : 11 12
THEN                 : 79
TIMES                : 34
TOO                  : 8
UNSURE               : 35 36 37
WAS                  : 7 8 9 32 35 36 37
WHAT                 : 32
WHICH                : 35 36 37
^                    : 51
error                : 
|                    : 50
~                    : 61

Nonterminals, with rules where they appear

actualParams         : 33 70
actualParamsList     : 71 74
body                 : 11 12 24
compoundStmt         : 19 20 22 34 35 35 37 38 39
conditionalStmt      : 36 37 39
decl                 : 2 3
decls                : 1 2 19
expr                 : 9 10 26 26 27 28 29 30 31 32 34 35 38 39 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 61 62 63 65 69 73 74
formalParam          : 15 16
formalParams         : 11 12
formalParamsList     : 14 16
funcDecl             : 5
procDecl             : 6
refType              : 18
root                 : 0
stmt                 : 22 23
terminator           : 7 8 9 10 26 27 28 30 31 33
type                 : 7 8 9 10 11 17 43
varDecl              : 4

Generating LALR tables
Parsing method: LALR

state 0

    (0) S' -> . root
    (1) root -> . decls
    (2) decls -> . decls decl
    (3) decls -> . decl
    (4) decl -> . varDecl
    (5) decl -> . funcDecl
    (6) decl -> . procDecl
    (7) varDecl -> . ID WAS A type terminator
    (8) varDecl -> . ID WAS A type TOO terminator
    (9) varDecl -> . ID WAS A type OF expr terminator
    (10) varDecl -> . ID HAD expr type terminator
    (11) funcDecl -> . THE ROOM ID formalParams CONTAINED A type body
    (12) procDecl -> . THE LOOKING - GLASS ID formalParams body

    ID              shift and go to state 6
    THE             shift and go to state 5

    decl                           shift and go to state 1
    procDecl                       shift and go to state 3
    funcDecl                       shift and go to state 2
    varDecl                        shift and go to state 4
    decls                          shift and go to state 7
    root                           shift and go to state 8

state 1

    (3) decls -> decl .

    ID              reduce using rule 3 (decls -> decl .)
    THE             reduce using rule 3 (decls -> decl .)
    $end            reduce using rule 3 (decls -> decl .)
    .               reduce using rule 3 (decls -> decl .)
    ALICE           reduce using rule 3 (decls -> decl .)
    WHAT            reduce using rule 3 (decls -> decl .)
    EVENTUALLY      reduce using rule 3 (decls -> decl .)
    EITHER          reduce using rule 3 (decls -> decl .)
    OPENED          reduce using rule 3 (decls -> decl .)
    LOGICAL_NOT     reduce using rule 3 (decls -> decl .)
    ~               reduce using rule 3 (decls -> decl .)
    +               reduce using rule 3 (decls -> decl .)
    -               reduce using rule 3 (decls -> decl .)
    STRING_LITERAL  reduce using rule 3 (decls -> decl .)
    CHAR_LITERAL    reduce using rule 3 (decls -> decl .)
    INT_LITERAL     reduce using rule 3 (decls -> decl .)
    (               reduce using rule 3 (decls -> decl .)
    PERHAPS         reduce using rule 3 (decls -> decl .)


state 2

    (5) decl -> funcDecl .

    ID              reduce using rule 5 (decl -> funcDecl .)
    THE             reduce using rule 5 (decl -> funcDecl .)
    $end            reduce using rule 5 (decl -> funcDecl .)
    .               reduce using rule 5 (decl -> funcDecl .)
    ALICE           reduce using rule 5 (decl -> funcDecl .)
    WHAT            reduce using rule 5 (decl -> funcDecl .)
    EVENTUALLY      reduce using rule 5 (decl -> funcDecl .)
    EITHER          reduce using rule 5 (decl -> funcDecl .)
    OPENED          reduce using rule 5 (decl -> funcDecl .)
    LOGICAL_NOT     reduce using rule 5 (decl -> funcDecl .)
    ~               reduce using rule 5 (decl -> funcDecl .)
    +               reduce using rule 5 (decl -> funcDecl .)
    -               reduce using rule 5 (decl -> funcDecl .)
    STRING_LITERAL  reduce using rule 5 (decl -> funcDecl .)
    CHAR_LITERAL    reduce using rule 5 (decl -> funcDecl .)
    INT_LITERAL     reduce using rule 5 (decl -> funcDecl .)
    (               reduce using rule 5 (decl -> funcDecl .)
    PERHAPS         reduce using rule 5 (decl -> funcDecl .)


state 3

    (6) decl -> procDecl .

    ID              reduce using rule 6 (decl -> procDecl .)
    THE             reduce using rule 6 (decl -> procDecl .)
    $end            reduce using rule 6 (decl -> procDecl .)
    .               reduce using rule 6 (decl -> procDecl .)
    ALICE           reduce using rule 6 (decl -> procDecl .)
    WHAT            reduce using rule 6 (decl -> procDecl .)
    EVENTUALLY      reduce using rule 6 (decl -> procDecl .)
    EITHER          reduce using rule 6 (decl -> procDecl .)
    OPENED          reduce using rule 6 (decl -> procDecl .)
    LOGICAL_NOT     reduce using rule 6 (decl -> procDecl .)
    ~               reduce using rule 6 (decl -> procDecl .)
    +               reduce using rule 6 (decl -> procDecl .)
    -               reduce using rule 6 (decl -> procDecl .)
    STRING_LITERAL  reduce using rule 6 (decl -> procDecl .)
    CHAR_LITERAL    reduce using rule 6 (decl -> procDecl .)
    INT_LITERAL     reduce using rule 6 (decl -> procDecl .)
    (               reduce using rule 6 (decl -> procDecl .)
    PERHAPS         reduce using rule 6 (decl -> procDecl .)


state 4

    (4) decl -> varDecl .

    ID              reduce using rule 4 (decl -> varDecl .)
    THE             reduce using rule 4 (decl -> varDecl .)
    $end            reduce using rule 4 (decl -> varDecl .)
    .               reduce using rule 4 (decl -> varDecl .)
    ALICE           reduce using rule 4 (decl -> varDecl .)
    WHAT            reduce using rule 4 (decl -> varDecl .)
    EVENTUALLY      reduce using rule 4 (decl -> varDecl .)
    EITHER          reduce using rule 4 (decl -> varDecl .)
    OPENED          reduce using rule 4 (decl -> varDecl .)
    LOGICAL_NOT     reduce using rule 4 (decl -> varDecl .)
    ~               reduce using rule 4 (decl -> varDecl .)
    +               reduce using rule 4 (decl -> varDecl .)
    -               reduce using rule 4 (decl -> varDecl .)
    STRING_LITERAL  reduce using rule 4 (decl -> varDecl .)
    CHAR_LITERAL    reduce using rule 4 (decl -> varDecl .)
    INT_LITERAL     reduce using rule 4 (decl -> varDecl .)
    (               reduce using rule 4 (decl -> varDecl .)
    PERHAPS         reduce using rule 4 (decl -> varDecl .)


state 5

    (11) funcDecl -> THE . ROOM ID formalParams CONTAINED A type body
    (12) procDecl -> THE . LOOKING - GLASS ID formalParams body

    ROOM            shift and go to state 9
    LOOKING         shift and go to state 10


state 6

    (7) varDecl -> ID . WAS A type terminator
    (8) varDecl -> ID . WAS A type TOO terminator
    (9) varDecl -> ID . WAS A type OF expr terminator
    (10) varDecl -> ID . HAD expr type terminator

    WAS             shift and go to state 11
    HAD             shift and go to state 12


state 7

    (1) root -> decls .
    (2) decls -> decls . decl
    (4) decl -> . varDecl
    (5) decl -> . funcDecl
    (6) decl -> . procDecl
    (7) varDecl -> . ID WAS A type terminator
    (8) varDecl -> . ID WAS A type TOO terminator
    (9) varDecl -> . ID WAS A type OF expr terminator
    (10) varDecl -> . ID HAD expr type terminator
    (11) funcDecl -> . THE ROOM ID formalParams CONTAINED A type body
    (12) procDecl -> . THE LOOKING - GLASS ID formalParams body

    $end            reduce using rule 1 (root -> decls .)
    ID              shift and go to state 6
    THE             shift and go to state 5

    decl                           shift and go to state 13
    procDecl                       shift and go to state 3
    funcDecl                       shift and go to state 2
    varDecl                        shift and go to state 4

state 8

    (0) S' -> root .



state 9

    (11) funcDecl -> THE ROOM . ID formalParams CONTAINED A type body

    ID              shift and go to state 14


state 10

    (12) procDecl -> THE LOOKING . - GLASS ID formalParams body

    -               shift and go to state 15


state 11

    (7) varDecl -> ID WAS . A type terminator
    (8) varDecl -> ID WAS . A type TOO terminator
    (9) varDecl -> ID WAS . A type OF expr terminator

    A               shift and go to state 16


state 12

    (10) varDecl -> ID HAD . expr type terminator
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 23

state 13

    (2) decls -> decls decl .

    ID              reduce using rule 2 (decls -> decls decl .)
    THE             reduce using rule 2 (decls -> decls decl .)
    $end            reduce using rule 2 (decls -> decls decl .)
    .               reduce using rule 2 (decls -> decls decl .)
    ALICE           reduce using rule 2 (decls -> decls decl .)
    WHAT            reduce using rule 2 (decls -> decls decl .)
    EVENTUALLY      reduce using rule 2 (decls -> decls decl .)
    EITHER          reduce using rule 2 (decls -> decls decl .)
    OPENED          reduce using rule 2 (decls -> decls decl .)
    LOGICAL_NOT     reduce using rule 2 (decls -> decls decl .)
    ~               reduce using rule 2 (decls -> decls decl .)
    +               reduce using rule 2 (decls -> decls decl .)
    -               reduce using rule 2 (decls -> decls decl .)
    STRING_LITERAL  reduce using rule 2 (decls -> decls decl .)
    CHAR_LITERAL    reduce using rule 2 (decls -> decls decl .)
    INT_LITERAL     reduce using rule 2 (decls -> decls decl .)
    (               reduce using rule 2 (decls -> decls decl .)
    PERHAPS         reduce using rule 2 (decls -> decls decl .)


state 14

    (11) funcDecl -> THE ROOM ID . formalParams CONTAINED A type body
    (13) formalParams -> . ( )
    (14) formalParams -> . ( formalParamsList )

    (               shift and go to state 27

    formalParams                   shift and go to state 28

state 15

    (12) procDecl -> THE LOOKING - . GLASS ID formalParams body

    GLASS           shift and go to state 29


state 16

    (7) varDecl -> ID WAS A . type terminator
    (8) varDecl -> ID WAS A . type TOO terminator
    (9) varDecl -> ID WAS A . type OF expr terminator
    (40) type -> . NUMBER
    (41) type -> . LETTER
    (42) type -> . SENTENCE

    NUMBER          shift and go to state 31
    LETTER          shift and go to state 32
    SENTENCE        shift and go to state 30

    type                           shift and go to state 33

state 17

    (69) expr -> ( . expr )
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 34

state 18

    (62) expr -> + . expr
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 35

state 19

    (63) expr -> - . expr
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 36

state 20

    (64) expr -> ID .
    (65) expr -> ID . APOSTROPHE S expr PIECE
    (70) expr -> ID . actualParams
    (71) actualParams -> . ( actualParamsList )
    (72) actualParams -> . ( )

    +               reduce using rule 64 (expr -> ID .)
    -               reduce using rule 64 (expr -> ID .)
    *               reduce using rule 64 (expr -> ID .)
    /               reduce using rule 64 (expr -> ID .)
    %               reduce using rule 64 (expr -> ID .)
    &               reduce using rule 64 (expr -> ID .)
    |               reduce using rule 64 (expr -> ID .)
    ^               reduce using rule 64 (expr -> ID .)
    LOGICAL_OR      reduce using rule 64 (expr -> ID .)
    LOGICAL_AND     reduce using rule 64 (expr -> ID .)
    GREATER_THAN    reduce using rule 64 (expr -> ID .)
    LESS_THAN       reduce using rule 64 (expr -> ID .)
    GREATER_EQUAL   reduce using rule 64 (expr -> ID .)
    LESS_EQUAL      reduce using rule 64 (expr -> ID .)
    EQUAL           reduce using rule 64 (expr -> ID .)
    NOT_EQUAL       reduce using rule 64 (expr -> ID .)
    NUMBER          reduce using rule 64 (expr -> ID .)
    LETTER          reduce using rule 64 (expr -> ID .)
    SENTENCE        reduce using rule 64 (expr -> ID .)
    )               reduce using rule 64 (expr -> ID .)
    ,               reduce using rule 64 (expr -> ID .)
    .               reduce using rule 64 (expr -> ID .)
    AND             reduce using rule 64 (expr -> ID .)
    BUT             reduce using rule 64 (expr -> ID .)
    THEN            reduce using rule 64 (expr -> ID .)
    PIECE           reduce using rule 64 (expr -> ID .)
    BECAME          reduce using rule 64 (expr -> ID .)
    ATE             reduce using rule 64 (expr -> ID .)
    DRANK           reduce using rule 64 (expr -> ID .)
    SPOKE           reduce using rule 64 (expr -> ID .)
    SAID            reduce using rule 64 (expr -> ID .)
    ?               reduce using rule 64 (expr -> ID .)
    APOSTROPHE      shift and go to state 39
    (               shift and go to state 38

    actualParams                   shift and go to state 37

state 21

    (60) expr -> LOGICAL_NOT . expr
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 40

state 22

    (66) expr -> STRING_LITERAL .

    +               reduce using rule 66 (expr -> STRING_LITERAL .)
    -               reduce using rule 66 (expr -> STRING_LITERAL .)
    *               reduce using rule 66 (expr -> STRING_LITERAL .)
    /               reduce using rule 66 (expr -> STRING_LITERAL .)
    %               reduce using rule 66 (expr -> STRING_LITERAL .)
    &               reduce using rule 66 (expr -> STRING_LITERAL .)
    |               reduce using rule 66 (expr -> STRING_LITERAL .)
    ^               reduce using rule 66 (expr -> STRING_LITERAL .)
    LOGICAL_OR      reduce using rule 66 (expr -> STRING_LITERAL .)
    LOGICAL_AND     reduce using rule 66 (expr -> STRING_LITERAL .)
    GREATER_THAN    reduce using rule 66 (expr -> STRING_LITERAL .)
    LESS_THAN       reduce using rule 66 (expr -> STRING_LITERAL .)
    GREATER_EQUAL   reduce using rule 66 (expr -> STRING_LITERAL .)
    LESS_EQUAL      reduce using rule 66 (expr -> STRING_LITERAL .)
    EQUAL           reduce using rule 66 (expr -> STRING_LITERAL .)
    NOT_EQUAL       reduce using rule 66 (expr -> STRING_LITERAL .)
    NUMBER          reduce using rule 66 (expr -> STRING_LITERAL .)
    LETTER          reduce using rule 66 (expr -> STRING_LITERAL .)
    SENTENCE        reduce using rule 66 (expr -> STRING_LITERAL .)
    )               reduce using rule 66 (expr -> STRING_LITERAL .)
    ,               reduce using rule 66 (expr -> STRING_LITERAL .)
    .               reduce using rule 66 (expr -> STRING_LITERAL .)
    AND             reduce using rule 66 (expr -> STRING_LITERAL .)
    BUT             reduce using rule 66 (expr -> STRING_LITERAL .)
    THEN            reduce using rule 66 (expr -> STRING_LITERAL .)
    PIECE           reduce using rule 66 (expr -> STRING_LITERAL .)
    BECAME          reduce using rule 66 (expr -> STRING_LITERAL .)
    ATE             reduce using rule 66 (expr -> STRING_LITERAL .)
    DRANK           reduce using rule 66 (expr -> STRING_LITERAL .)
    SPOKE           reduce using rule 66 (expr -> STRING_LITERAL .)
    SAID            reduce using rule 66 (expr -> STRING_LITERAL .)
    ?               reduce using rule 66 (expr -> STRING_LITERAL .)


state 23

    (10) varDecl -> ID HAD expr . type terminator
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr
    (40) type -> . NUMBER
    (41) type -> . LETTER
    (42) type -> . SENTENCE

    +               shift and go to state 48
    -               shift and go to state 50
    *               shift and go to state 49
    /               shift and go to state 51
    %               shift and go to state 45
    &               shift and go to state 47
    |               shift and go to state 57
    ^               shift and go to state 55
    LOGICAL_OR      shift and go to state 56
    LOGICAL_AND     shift and go to state 42
    GREATER_THAN    shift and go to state 41
    LESS_THAN       shift and go to state 43
    GREATER_EQUAL   shift and go to state 46
    LESS_EQUAL      shift and go to state 54
    EQUAL           shift and go to state 53
    NOT_EQUAL       shift and go to state 44
    NUMBER          shift and go to state 31
    LETTER          shift and go to state 32
    SENTENCE        shift and go to state 30

    type                           shift and go to state 52

state 24

    (67) expr -> CHAR_LITERAL .

    +               reduce using rule 67 (expr -> CHAR_LITERAL .)
    -               reduce using rule 67 (expr -> CHAR_LITERAL .)
    *               reduce using rule 67 (expr -> CHAR_LITERAL .)
    /               reduce using rule 67 (expr -> CHAR_LITERAL .)
    %               reduce using rule 67 (expr -> CHAR_LITERAL .)
    &               reduce using rule 67 (expr -> CHAR_LITERAL .)
    |               reduce using rule 67 (expr -> CHAR_LITERAL .)
    ^               reduce using rule 67 (expr -> CHAR_LITERAL .)
    LOGICAL_OR      reduce using rule 67 (expr -> CHAR_LITERAL .)
    LOGICAL_AND     reduce using rule 67 (expr -> CHAR_LITERAL .)
    GREATER_THAN    reduce using rule 67 (expr -> CHAR_LITERAL .)
    LESS_THAN       reduce using rule 67 (expr -> CHAR_LITERAL .)
    GREATER_EQUAL   reduce using rule 67 (expr -> CHAR_LITERAL .)
    LESS_EQUAL      reduce using rule 67 (expr -> CHAR_LITERAL .)
    EQUAL           reduce using rule 67 (expr -> CHAR_LITERAL .)
    NOT_EQUAL       reduce using rule 67 (expr -> CHAR_LITERAL .)
    NUMBER          reduce using rule 67 (expr -> CHAR_LITERAL .)
    LETTER          reduce using rule 67 (expr -> CHAR_LITERAL .)
    SENTENCE        reduce using rule 67 (expr -> CHAR_LITERAL .)
    )               reduce using rule 67 (expr -> CHAR_LITERAL .)
    ,               reduce using rule 67 (expr -> CHAR_LITERAL .)
    .               reduce using rule 67 (expr -> CHAR_LITERAL .)
    AND             reduce using rule 67 (expr -> CHAR_LITERAL .)
    BUT             reduce using rule 67 (expr -> CHAR_LITERAL .)
    THEN            reduce using rule 67 (expr -> CHAR_LITERAL .)
    PIECE           reduce using rule 67 (expr -> CHAR_LITERAL .)
    BECAME          reduce using rule 67 (expr -> CHAR_LITERAL .)
    ATE             reduce using rule 67 (expr -> CHAR_LITERAL .)
    DRANK           reduce using rule 67 (expr -> CHAR_LITERAL .)
    SPOKE           reduce using rule 67 (expr -> CHAR_LITERAL .)
    SAID            reduce using rule 67 (expr -> CHAR_LITERAL .)
    ?               reduce using rule 67 (expr -> CHAR_LITERAL .)


state 25

    (68) expr -> INT_LITERAL .

    +               reduce using rule 68 (expr -> INT_LITERAL .)
    -               reduce using rule 68 (expr -> INT_LITERAL .)
    *               reduce using rule 68 (expr -> INT_LITERAL .)
    /               reduce using rule 68 (expr -> INT_LITERAL .)
    %               reduce using rule 68 (expr -> INT_LITERAL .)
    &               reduce using rule 68 (expr -> INT_LITERAL .)
    |               reduce using rule 68 (expr -> INT_LITERAL .)
    ^               reduce using rule 68 (expr -> INT_LITERAL .)
    LOGICAL_OR      reduce using rule 68 (expr -> INT_LITERAL .)
    LOGICAL_AND     reduce using rule 68 (expr -> INT_LITERAL .)
    GREATER_THAN    reduce using rule 68 (expr -> INT_LITERAL .)
    LESS_THAN       reduce using rule 68 (expr -> INT_LITERAL .)
    GREATER_EQUAL   reduce using rule 68 (expr -> INT_LITERAL .)
    LESS_EQUAL      reduce using rule 68 (expr -> INT_LITERAL .)
    EQUAL           reduce using rule 68 (expr -> INT_LITERAL .)
    NOT_EQUAL       reduce using rule 68 (expr -> INT_LITERAL .)
    NUMBER          reduce using rule 68 (expr -> INT_LITERAL .)
    LETTER          reduce using rule 68 (expr -> INT_LITERAL .)
    SENTENCE        reduce using rule 68 (expr -> INT_LITERAL .)
    )               reduce using rule 68 (expr -> INT_LITERAL .)
    ,               reduce using rule 68 (expr -> INT_LITERAL .)
    .               reduce using rule 68 (expr -> INT_LITERAL .)
    AND             reduce using rule 68 (expr -> INT_LITERAL .)
    BUT             reduce using rule 68 (expr -> INT_LITERAL .)
    THEN            reduce using rule 68 (expr -> INT_LITERAL .)
    PIECE           reduce using rule 68 (expr -> INT_LITERAL .)
    BECAME          reduce using rule 68 (expr -> INT_LITERAL .)
    ATE             reduce using rule 68 (expr -> INT_LITERAL .)
    DRANK           reduce using rule 68 (expr -> INT_LITERAL .)
    SPOKE           reduce using rule 68 (expr -> INT_LITERAL .)
    SAID            reduce using rule 68 (expr -> INT_LITERAL .)
    ?               reduce using rule 68 (expr -> INT_LITERAL .)


state 26

    (61) expr -> ~ . expr
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 58

state 27

    (13) formalParams -> ( . )
    (14) formalParams -> ( . formalParamsList )
    (15) formalParamsList -> . formalParam
    (16) formalParamsList -> . formalParamsList , formalParam
    (17) formalParam -> . type ID
    (18) formalParam -> . refType ID
    (40) type -> . NUMBER
    (41) type -> . LETTER
    (42) type -> . SENTENCE
    (43) refType -> . SPIDER type

    )               shift and go to state 61
    NUMBER          shift and go to state 31
    LETTER          shift and go to state 32
    SENTENCE        shift and go to state 30
    SPIDER          shift and go to state 60

    refType                        shift and go to state 59
    formalParam                    shift and go to state 62
    type                           shift and go to state 63
    formalParamsList               shift and go to state 64

state 28

    (11) funcDecl -> THE ROOM ID formalParams . CONTAINED A type body

    CONTAINED       shift and go to state 65


state 29

    (12) procDecl -> THE LOOKING - GLASS . ID formalParams body

    ID              shift and go to state 66


state 30

    (42) type -> SENTENCE .

    OPENED          reduce using rule 42 (type -> SENTENCE .)
    ID              reduce using rule 42 (type -> SENTENCE .)
    .               reduce using rule 42 (type -> SENTENCE .)
    ,               reduce using rule 42 (type -> SENTENCE .)
    AND             reduce using rule 42 (type -> SENTENCE .)
    BUT             reduce using rule 42 (type -> SENTENCE .)
    THEN            reduce using rule 42 (type -> SENTENCE .)
    TOO             reduce using rule 42 (type -> SENTENCE .)
    OF              reduce using rule 42 (type -> SENTENCE .)


state 31

    (40) type -> NUMBER .

    OPENED          reduce using rule 40 (type -> NUMBER .)
    ID              reduce using rule 40 (type -> NUMBER .)
    .               reduce using rule 40 (type -> NUMBER .)
    ,               reduce using rule 40 (type -> NUMBER .)
    AND             reduce using rule 40 (type -> NUMBER .)
    BUT             reduce using rule 40 (type -> NUMBER .)
    THEN            reduce using rule 40 (type -> NUMBER .)
    TOO             reduce using rule 40 (type -> NUMBER .)
    OF              reduce using rule 40 (type -> NUMBER .)


state 32

    (41) type -> LETTER .

    OPENED          reduce using rule 41 (type -> LETTER .)
    ID              reduce using rule 41 (type -> LETTER .)
    .               reduce using rule 41 (type -> LETTER .)
    ,               reduce using rule 41 (type -> LETTER .)
    AND             reduce using rule 41 (type -> LETTER .)
    BUT             reduce using rule 41 (type -> LETTER .)
    THEN            reduce using rule 41 (type -> LETTER .)
    TOO             reduce using rule 41 (type -> LETTER .)
    OF              reduce using rule 41 (type -> LETTER .)


state 33

    (7) varDecl -> ID WAS A type . terminator
    (8) varDecl -> ID WAS A type . TOO terminator
    (9) varDecl -> ID WAS A type . OF expr terminator
    (75) terminator -> . .
    (76) terminator -> . ,
    (77) terminator -> . AND
    (78) terminator -> . BUT
    (79) terminator -> . THEN

    TOO             shift and go to state 71
    OF              shift and go to state 72
    .               shift and go to state 73
    ,               shift and go to state 69
    AND             shift and go to state 67
    BUT             shift and go to state 70
    THEN            shift and go to state 68

    terminator                     shift and go to state 74

state 34

    (69) expr -> ( expr . )
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    )               shift and go to state 75
    +               shift and go to state 48
    -               shift and go to state 50
    *               shift and go to state 49
    /               shift and go to state 51
    %               shift and go to state 45
    &               shift and go to state 47
    |               shift and go to state 57
    ^               shift and go to state 55
    LOGICAL_OR      shift and go to state 56
    LOGICAL_AND     shift and go to state 42
    GREATER_THAN    shift and go to state 41
    LESS_THAN       shift and go to state 43
    GREATER_EQUAL   shift and go to state 46
    LESS_EQUAL      shift and go to state 54
    EQUAL           shift and go to state 53
    NOT_EQUAL       shift and go to state 44


state 35

    (62) expr -> + expr .
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    +               reduce using rule 62 (expr -> + expr .)
    -               reduce using rule 62 (expr -> + expr .)
    *               reduce using rule 62 (expr -> + expr .)
    /               reduce using rule 62 (expr -> + expr .)
    %               reduce using rule 62 (expr -> + expr .)
    &               reduce using rule 62 (expr -> + expr .)
    |               reduce using rule 62 (expr -> + expr .)
    ^               reduce using rule 62 (expr -> + expr .)
    LOGICAL_OR      reduce using rule 62 (expr -> + expr .)
    LOGICAL_AND     reduce using rule 62 (expr -> + expr .)
    GREATER_THAN    reduce using rule 62 (expr -> + expr .)
    LESS_THAN       reduce using rule 62 (expr -> + expr .)
    GREATER_EQUAL   reduce using rule 62 (expr -> + expr .)
    LESS_EQUAL      reduce using rule 62 (expr -> + expr .)
    EQUAL           reduce using rule 62 (expr -> + expr .)
    NOT_EQUAL       reduce using rule 62 (expr -> + expr .)
    NUMBER          reduce using rule 62 (expr -> + expr .)
    LETTER          reduce using rule 62 (expr -> + expr .)
    SENTENCE        reduce using rule 62 (expr -> + expr .)
    )               reduce using rule 62 (expr -> + expr .)
    ,               reduce using rule 62 (expr -> + expr .)
    .               reduce using rule 62 (expr -> + expr .)
    AND             reduce using rule 62 (expr -> + expr .)
    BUT             reduce using rule 62 (expr -> + expr .)
    THEN            reduce using rule 62 (expr -> + expr .)
    PIECE           reduce using rule 62 (expr -> + expr .)
    BECAME          reduce using rule 62 (expr -> + expr .)
    ATE             reduce using rule 62 (expr -> + expr .)
    DRANK           reduce using rule 62 (expr -> + expr .)
    SPOKE           reduce using rule 62 (expr -> + expr .)
    SAID            reduce using rule 62 (expr -> + expr .)
    ?               reduce using rule 62 (expr -> + expr .)

  ! +               [ shift and go to state 48 ]
  ! -               [ shift and go to state 50 ]
  ! *               [ shift and go to state 49 ]
  ! /               [ shift and go to state 51 ]
  ! %               [ shift and go to state 45 ]
  ! &               [ shift and go to state 47 ]
  ! |               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 55 ]
  ! LOGICAL_OR      [ shift and go to state 56 ]
  ! LOGICAL_AND     [ shift and go to state 42 ]
  ! GREATER_THAN    [ shift and go to state 41 ]
  ! LESS_THAN       [ shift and go to state 43 ]
  ! GREATER_EQUAL   [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 54 ]
  ! EQUAL           [ shift and go to state 53 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]


state 36

    (63) expr -> - expr .
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    +               reduce using rule 63 (expr -> - expr .)
    -               reduce using rule 63 (expr -> - expr .)
    *               reduce using rule 63 (expr -> - expr .)
    /               reduce using rule 63 (expr -> - expr .)
    %               reduce using rule 63 (expr -> - expr .)
    &               reduce using rule 63 (expr -> - expr .)
    |               reduce using rule 63 (expr -> - expr .)
    ^               reduce using rule 63 (expr -> - expr .)
    LOGICAL_OR      reduce using rule 63 (expr -> - expr .)
    LOGICAL_AND     reduce using rule 63 (expr -> - expr .)
    GREATER_THAN    reduce using rule 63 (expr -> - expr .)
    LESS_THAN       reduce using rule 63 (expr -> - expr .)
    GREATER_EQUAL   reduce using rule 63 (expr -> - expr .)
    LESS_EQUAL      reduce using rule 63 (expr -> - expr .)
    EQUAL           reduce using rule 63 (expr -> - expr .)
    NOT_EQUAL       reduce using rule 63 (expr -> - expr .)
    NUMBER          reduce using rule 63 (expr -> - expr .)
    LETTER          reduce using rule 63 (expr -> - expr .)
    SENTENCE        reduce using rule 63 (expr -> - expr .)
    )               reduce using rule 63 (expr -> - expr .)
    ,               reduce using rule 63 (expr -> - expr .)
    .               reduce using rule 63 (expr -> - expr .)
    AND             reduce using rule 63 (expr -> - expr .)
    BUT             reduce using rule 63 (expr -> - expr .)
    THEN            reduce using rule 63 (expr -> - expr .)
    PIECE           reduce using rule 63 (expr -> - expr .)
    BECAME          reduce using rule 63 (expr -> - expr .)
    ATE             reduce using rule 63 (expr -> - expr .)
    DRANK           reduce using rule 63 (expr -> - expr .)
    SPOKE           reduce using rule 63 (expr -> - expr .)
    SAID            reduce using rule 63 (expr -> - expr .)
    ?               reduce using rule 63 (expr -> - expr .)

  ! +               [ shift and go to state 48 ]
  ! -               [ shift and go to state 50 ]
  ! *               [ shift and go to state 49 ]
  ! /               [ shift and go to state 51 ]
  ! %               [ shift and go to state 45 ]
  ! &               [ shift and go to state 47 ]
  ! |               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 55 ]
  ! LOGICAL_OR      [ shift and go to state 56 ]
  ! LOGICAL_AND     [ shift and go to state 42 ]
  ! GREATER_THAN    [ shift and go to state 41 ]
  ! LESS_THAN       [ shift and go to state 43 ]
  ! GREATER_EQUAL   [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 54 ]
  ! EQUAL           [ shift and go to state 53 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]


state 37

    (70) expr -> ID actualParams .

    +               reduce using rule 70 (expr -> ID actualParams .)
    -               reduce using rule 70 (expr -> ID actualParams .)
    *               reduce using rule 70 (expr -> ID actualParams .)
    /               reduce using rule 70 (expr -> ID actualParams .)
    %               reduce using rule 70 (expr -> ID actualParams .)
    &               reduce using rule 70 (expr -> ID actualParams .)
    |               reduce using rule 70 (expr -> ID actualParams .)
    ^               reduce using rule 70 (expr -> ID actualParams .)
    LOGICAL_OR      reduce using rule 70 (expr -> ID actualParams .)
    LOGICAL_AND     reduce using rule 70 (expr -> ID actualParams .)
    GREATER_THAN    reduce using rule 70 (expr -> ID actualParams .)
    LESS_THAN       reduce using rule 70 (expr -> ID actualParams .)
    GREATER_EQUAL   reduce using rule 70 (expr -> ID actualParams .)
    LESS_EQUAL      reduce using rule 70 (expr -> ID actualParams .)
    EQUAL           reduce using rule 70 (expr -> ID actualParams .)
    NOT_EQUAL       reduce using rule 70 (expr -> ID actualParams .)
    NUMBER          reduce using rule 70 (expr -> ID actualParams .)
    LETTER          reduce using rule 70 (expr -> ID actualParams .)
    SENTENCE        reduce using rule 70 (expr -> ID actualParams .)
    )               reduce using rule 70 (expr -> ID actualParams .)
    ,               reduce using rule 70 (expr -> ID actualParams .)
    .               reduce using rule 70 (expr -> ID actualParams .)
    AND             reduce using rule 70 (expr -> ID actualParams .)
    BUT             reduce using rule 70 (expr -> ID actualParams .)
    THEN            reduce using rule 70 (expr -> ID actualParams .)
    PIECE           reduce using rule 70 (expr -> ID actualParams .)
    BECAME          reduce using rule 70 (expr -> ID actualParams .)
    ATE             reduce using rule 70 (expr -> ID actualParams .)
    DRANK           reduce using rule 70 (expr -> ID actualParams .)
    SPOKE           reduce using rule 70 (expr -> ID actualParams .)
    SAID            reduce using rule 70 (expr -> ID actualParams .)
    ?               reduce using rule 70 (expr -> ID actualParams .)


state 38

    (71) actualParams -> ( . actualParamsList )
    (72) actualParams -> ( . )
    (73) actualParamsList -> . expr
    (74) actualParamsList -> . actualParamsList , expr
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    )               shift and go to state 77
    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 78
    actualParamsList               shift and go to state 76

state 39

    (65) expr -> ID APOSTROPHE . S expr PIECE

    S               shift and go to state 79


state 40

    (60) expr -> LOGICAL_NOT expr .
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    +               reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    -               reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    *               reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    /               reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    %               reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    &               reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    |               reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    ^               reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    LOGICAL_OR      reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    LOGICAL_AND     reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    GREATER_THAN    reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    LESS_THAN       reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    GREATER_EQUAL   reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    LESS_EQUAL      reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    EQUAL           reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    NOT_EQUAL       reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    NUMBER          reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    LETTER          reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    SENTENCE        reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    )               reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    ,               reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    .               reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    AND             reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    BUT             reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    THEN            reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    PIECE           reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    BECAME          reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    ATE             reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    DRANK           reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    SPOKE           reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    SAID            reduce using rule 60 (expr -> LOGICAL_NOT expr .)
    ?               reduce using rule 60 (expr -> LOGICAL_NOT expr .)

  ! +               [ shift and go to state 48 ]
  ! -               [ shift and go to state 50 ]
  ! *               [ shift and go to state 49 ]
  ! /               [ shift and go to state 51 ]
  ! %               [ shift and go to state 45 ]
  ! &               [ shift and go to state 47 ]
  ! |               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 55 ]
  ! LOGICAL_OR      [ shift and go to state 56 ]
  ! LOGICAL_AND     [ shift and go to state 42 ]
  ! GREATER_THAN    [ shift and go to state 41 ]
  ! LESS_THAN       [ shift and go to state 43 ]
  ! GREATER_EQUAL   [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 54 ]
  ! EQUAL           [ shift and go to state 53 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]


state 41

    (54) expr -> expr GREATER_THAN . expr
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 80

state 42

    (53) expr -> expr LOGICAL_AND . expr
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 81

state 43

    (55) expr -> expr LESS_THAN . expr
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 82

state 44

    (59) expr -> expr NOT_EQUAL . expr
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 83

state 45

    (48) expr -> expr % . expr
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 84

state 46

    (56) expr -> expr GREATER_EQUAL . expr
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 85

state 47

    (49) expr -> expr & . expr
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 86

state 48

    (44) expr -> expr + . expr
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 87

state 49

    (46) expr -> expr * . expr
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 88

state 50

    (45) expr -> expr - . expr
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 89

state 51

    (47) expr -> expr / . expr
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 90

state 52

    (10) varDecl -> ID HAD expr type . terminator
    (75) terminator -> . .
    (76) terminator -> . ,
    (77) terminator -> . AND
    (78) terminator -> . BUT
    (79) terminator -> . THEN

    .               shift and go to state 73
    ,               shift and go to state 69
    AND             shift and go to state 67
    BUT             shift and go to state 70
    THEN            shift and go to state 68

    terminator                     shift and go to state 91

state 53

    (58) expr -> expr EQUAL . expr
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 92

state 54

    (57) expr -> expr LESS_EQUAL . expr
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 93

state 55

    (51) expr -> expr ^ . expr
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 94

state 56

    (52) expr -> expr LOGICAL_OR . expr
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 95

state 57

    (50) expr -> expr | . expr
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 96

state 58

    (61) expr -> ~ expr .
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    +               reduce using rule 61 (expr -> ~ expr .)
    -               reduce using rule 61 (expr -> ~ expr .)
    *               reduce using rule 61 (expr -> ~ expr .)
    /               reduce using rule 61 (expr -> ~ expr .)
    %               reduce using rule 61 (expr -> ~ expr .)
    &               reduce using rule 61 (expr -> ~ expr .)
    |               reduce using rule 61 (expr -> ~ expr .)
    ^               reduce using rule 61 (expr -> ~ expr .)
    LOGICAL_OR      reduce using rule 61 (expr -> ~ expr .)
    LOGICAL_AND     reduce using rule 61 (expr -> ~ expr .)
    GREATER_THAN    reduce using rule 61 (expr -> ~ expr .)
    LESS_THAN       reduce using rule 61 (expr -> ~ expr .)
    GREATER_EQUAL   reduce using rule 61 (expr -> ~ expr .)
    LESS_EQUAL      reduce using rule 61 (expr -> ~ expr .)
    EQUAL           reduce using rule 61 (expr -> ~ expr .)
    NOT_EQUAL       reduce using rule 61 (expr -> ~ expr .)
    NUMBER          reduce using rule 61 (expr -> ~ expr .)
    LETTER          reduce using rule 61 (expr -> ~ expr .)
    SENTENCE        reduce using rule 61 (expr -> ~ expr .)
    )               reduce using rule 61 (expr -> ~ expr .)
    ,               reduce using rule 61 (expr -> ~ expr .)
    .               reduce using rule 61 (expr -> ~ expr .)
    AND             reduce using rule 61 (expr -> ~ expr .)
    BUT             reduce using rule 61 (expr -> ~ expr .)
    THEN            reduce using rule 61 (expr -> ~ expr .)
    PIECE           reduce using rule 61 (expr -> ~ expr .)
    BECAME          reduce using rule 61 (expr -> ~ expr .)
    ATE             reduce using rule 61 (expr -> ~ expr .)
    DRANK           reduce using rule 61 (expr -> ~ expr .)
    SPOKE           reduce using rule 61 (expr -> ~ expr .)
    SAID            reduce using rule 61 (expr -> ~ expr .)
    ?               reduce using rule 61 (expr -> ~ expr .)

  ! +               [ shift and go to state 48 ]
  ! -               [ shift and go to state 50 ]
  ! *               [ shift and go to state 49 ]
  ! /               [ shift and go to state 51 ]
  ! %               [ shift and go to state 45 ]
  ! &               [ shift and go to state 47 ]
  ! |               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 55 ]
  ! LOGICAL_OR      [ shift and go to state 56 ]
  ! LOGICAL_AND     [ shift and go to state 42 ]
  ! GREATER_THAN    [ shift and go to state 41 ]
  ! LESS_THAN       [ shift and go to state 43 ]
  ! GREATER_EQUAL   [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 54 ]
  ! EQUAL           [ shift and go to state 53 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]


state 59

    (18) formalParam -> refType . ID

    ID              shift and go to state 97


state 60

    (43) refType -> SPIDER . type
    (40) type -> . NUMBER
    (41) type -> . LETTER
    (42) type -> . SENTENCE

    NUMBER          shift and go to state 31
    LETTER          shift and go to state 32
    SENTENCE        shift and go to state 30

    type                           shift and go to state 98

state 61

    (13) formalParams -> ( ) .

    OPENED          reduce using rule 13 (formalParams -> ( ) .)
    CONTAINED       reduce using rule 13 (formalParams -> ( ) .)


state 62

    (15) formalParamsList -> formalParam .

    )               reduce using rule 15 (formalParamsList -> formalParam .)
    ,               reduce using rule 15 (formalParamsList -> formalParam .)


state 63

    (17) formalParam -> type . ID

    ID              shift and go to state 99


state 64

    (14) formalParams -> ( formalParamsList . )
    (16) formalParamsList -> formalParamsList . , formalParam

    )               shift and go to state 100
    ,               shift and go to state 101


state 65

    (11) funcDecl -> THE ROOM ID formalParams CONTAINED . A type body

    A               shift and go to state 102


state 66

    (12) procDecl -> THE LOOKING - GLASS ID . formalParams body
    (13) formalParams -> . ( )
    (14) formalParams -> . ( formalParamsList )

    (               shift and go to state 27

    formalParams                   shift and go to state 103

state 67

    (77) terminator -> AND .

    CLOSED          reduce using rule 77 (terminator -> AND .)
    .               reduce using rule 77 (terminator -> AND .)
    ALICE           reduce using rule 77 (terminator -> AND .)
    WHAT            reduce using rule 77 (terminator -> AND .)
    ID              reduce using rule 77 (terminator -> AND .)
    EVENTUALLY      reduce using rule 77 (terminator -> AND .)
    EITHER          reduce using rule 77 (terminator -> AND .)
    OPENED          reduce using rule 77 (terminator -> AND .)
    LOGICAL_NOT     reduce using rule 77 (terminator -> AND .)
    ~               reduce using rule 77 (terminator -> AND .)
    +               reduce using rule 77 (terminator -> AND .)
    -               reduce using rule 77 (terminator -> AND .)
    STRING_LITERAL  reduce using rule 77 (terminator -> AND .)
    CHAR_LITERAL    reduce using rule 77 (terminator -> AND .)
    INT_LITERAL     reduce using rule 77 (terminator -> AND .)
    (               reduce using rule 77 (terminator -> AND .)
    PERHAPS         reduce using rule 77 (terminator -> AND .)
    BECAUSE         reduce using rule 77 (terminator -> AND .)
    OR              reduce using rule 77 (terminator -> AND .)
    ENOUGH          reduce using rule 77 (terminator -> AND .)
    THE             reduce using rule 77 (terminator -> AND .)
    $end            reduce using rule 77 (terminator -> AND .)


state 68

    (79) terminator -> THEN .

    CLOSED          reduce using rule 79 (terminator -> THEN .)
    .               reduce using rule 79 (terminator -> THEN .)
    ALICE           reduce using rule 79 (terminator -> THEN .)
    WHAT            reduce using rule 79 (terminator -> THEN .)
    ID              reduce using rule 79 (terminator -> THEN .)
    EVENTUALLY      reduce using rule 79 (terminator -> THEN .)
    EITHER          reduce using rule 79 (terminator -> THEN .)
    OPENED          reduce using rule 79 (terminator -> THEN .)
    LOGICAL_NOT     reduce using rule 79 (terminator -> THEN .)
    ~               reduce using rule 79 (terminator -> THEN .)
    +               reduce using rule 79 (terminator -> THEN .)
    -               reduce using rule 79 (terminator -> THEN .)
    STRING_LITERAL  reduce using rule 79 (terminator -> THEN .)
    CHAR_LITERAL    reduce using rule 79 (terminator -> THEN .)
    INT_LITERAL     reduce using rule 79 (terminator -> THEN .)
    (               reduce using rule 79 (terminator -> THEN .)
    PERHAPS         reduce using rule 79 (terminator -> THEN .)
    BECAUSE         reduce using rule 79 (terminator -> THEN .)
    OR              reduce using rule 79 (terminator -> THEN .)
    ENOUGH          reduce using rule 79 (terminator -> THEN .)
    THE             reduce using rule 79 (terminator -> THEN .)
    $end            reduce using rule 79 (terminator -> THEN .)


state 69

    (76) terminator -> , .

    CLOSED          reduce using rule 76 (terminator -> , .)
    .               reduce using rule 76 (terminator -> , .)
    ALICE           reduce using rule 76 (terminator -> , .)
    WHAT            reduce using rule 76 (terminator -> , .)
    ID              reduce using rule 76 (terminator -> , .)
    EVENTUALLY      reduce using rule 76 (terminator -> , .)
    EITHER          reduce using rule 76 (terminator -> , .)
    OPENED          reduce using rule 76 (terminator -> , .)
    LOGICAL_NOT     reduce using rule 76 (terminator -> , .)
    ~               reduce using rule 76 (terminator -> , .)
    +               reduce using rule 76 (terminator -> , .)
    -               reduce using rule 76 (terminator -> , .)
    STRING_LITERAL  reduce using rule 76 (terminator -> , .)
    CHAR_LITERAL    reduce using rule 76 (terminator -> , .)
    INT_LITERAL     reduce using rule 76 (terminator -> , .)
    (               reduce using rule 76 (terminator -> , .)
    PERHAPS         reduce using rule 76 (terminator -> , .)
    BECAUSE         reduce using rule 76 (terminator -> , .)
    OR              reduce using rule 76 (terminator -> , .)
    ENOUGH          reduce using rule 76 (terminator -> , .)
    THE             reduce using rule 76 (terminator -> , .)
    $end            reduce using rule 76 (terminator -> , .)


state 70

    (78) terminator -> BUT .

    CLOSED          reduce using rule 78 (terminator -> BUT .)
    .               reduce using rule 78 (terminator -> BUT .)
    ALICE           reduce using rule 78 (terminator -> BUT .)
    WHAT            reduce using rule 78 (terminator -> BUT .)
    ID              reduce using rule 78 (terminator -> BUT .)
    EVENTUALLY      reduce using rule 78 (terminator -> BUT .)
    EITHER          reduce using rule 78 (terminator -> BUT .)
    OPENED          reduce using rule 78 (terminator -> BUT .)
    LOGICAL_NOT     reduce using rule 78 (terminator -> BUT .)
    ~               reduce using rule 78 (terminator -> BUT .)
    +               reduce using rule 78 (terminator -> BUT .)
    -               reduce using rule 78 (terminator -> BUT .)
    STRING_LITERAL  reduce using rule 78 (terminator -> BUT .)
    CHAR_LITERAL    reduce using rule 78 (terminator -> BUT .)
    INT_LITERAL     reduce using rule 78 (terminator -> BUT .)
    (               reduce using rule 78 (terminator -> BUT .)
    PERHAPS         reduce using rule 78 (terminator -> BUT .)
    BECAUSE         reduce using rule 78 (terminator -> BUT .)
    OR              reduce using rule 78 (terminator -> BUT .)
    ENOUGH          reduce using rule 78 (terminator -> BUT .)
    THE             reduce using rule 78 (terminator -> BUT .)
    $end            reduce using rule 78 (terminator -> BUT .)


state 71

    (8) varDecl -> ID WAS A type TOO . terminator
    (75) terminator -> . .
    (76) terminator -> . ,
    (77) terminator -> . AND
    (78) terminator -> . BUT
    (79) terminator -> . THEN

    .               shift and go to state 73
    ,               shift and go to state 69
    AND             shift and go to state 67
    BUT             shift and go to state 70
    THEN            shift and go to state 68

    terminator                     shift and go to state 104

state 72

    (9) varDecl -> ID WAS A type OF . expr terminator
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 105

state 73

    (75) terminator -> . .

    CLOSED          reduce using rule 75 (terminator -> . .)
    .               reduce using rule 75 (terminator -> . .)
    ALICE           reduce using rule 75 (terminator -> . .)
    WHAT            reduce using rule 75 (terminator -> . .)
    ID              reduce using rule 75 (terminator -> . .)
    EVENTUALLY      reduce using rule 75 (terminator -> . .)
    EITHER          reduce using rule 75 (terminator -> . .)
    OPENED          reduce using rule 75 (terminator -> . .)
    LOGICAL_NOT     reduce using rule 75 (terminator -> . .)
    ~               reduce using rule 75 (terminator -> . .)
    +               reduce using rule 75 (terminator -> . .)
    -               reduce using rule 75 (terminator -> . .)
    STRING_LITERAL  reduce using rule 75 (terminator -> . .)
    CHAR_LITERAL    reduce using rule 75 (terminator -> . .)
    INT_LITERAL     reduce using rule 75 (terminator -> . .)
    (               reduce using rule 75 (terminator -> . .)
    PERHAPS         reduce using rule 75 (terminator -> . .)
    BECAUSE         reduce using rule 75 (terminator -> . .)
    OR              reduce using rule 75 (terminator -> . .)
    ENOUGH          reduce using rule 75 (terminator -> . .)
    THE             reduce using rule 75 (terminator -> . .)
    $end            reduce using rule 75 (terminator -> . .)


state 74

    (7) varDecl -> ID WAS A type terminator .

    ID              reduce using rule 7 (varDecl -> ID WAS A type terminator .)
    THE             reduce using rule 7 (varDecl -> ID WAS A type terminator .)
    $end            reduce using rule 7 (varDecl -> ID WAS A type terminator .)
    .               reduce using rule 7 (varDecl -> ID WAS A type terminator .)
    ALICE           reduce using rule 7 (varDecl -> ID WAS A type terminator .)
    WHAT            reduce using rule 7 (varDecl -> ID WAS A type terminator .)
    EVENTUALLY      reduce using rule 7 (varDecl -> ID WAS A type terminator .)
    EITHER          reduce using rule 7 (varDecl -> ID WAS A type terminator .)
    OPENED          reduce using rule 7 (varDecl -> ID WAS A type terminator .)
    LOGICAL_NOT     reduce using rule 7 (varDecl -> ID WAS A type terminator .)
    ~               reduce using rule 7 (varDecl -> ID WAS A type terminator .)
    +               reduce using rule 7 (varDecl -> ID WAS A type terminator .)
    -               reduce using rule 7 (varDecl -> ID WAS A type terminator .)
    STRING_LITERAL  reduce using rule 7 (varDecl -> ID WAS A type terminator .)
    CHAR_LITERAL    reduce using rule 7 (varDecl -> ID WAS A type terminator .)
    INT_LITERAL     reduce using rule 7 (varDecl -> ID WAS A type terminator .)
    (               reduce using rule 7 (varDecl -> ID WAS A type terminator .)
    PERHAPS         reduce using rule 7 (varDecl -> ID WAS A type terminator .)


state 75

    (69) expr -> ( expr ) .

    +               reduce using rule 69 (expr -> ( expr ) .)
    -               reduce using rule 69 (expr -> ( expr ) .)
    *               reduce using rule 69 (expr -> ( expr ) .)
    /               reduce using rule 69 (expr -> ( expr ) .)
    %               reduce using rule 69 (expr -> ( expr ) .)
    &               reduce using rule 69 (expr -> ( expr ) .)
    |               reduce using rule 69 (expr -> ( expr ) .)
    ^               reduce using rule 69 (expr -> ( expr ) .)
    LOGICAL_OR      reduce using rule 69 (expr -> ( expr ) .)
    LOGICAL_AND     reduce using rule 69 (expr -> ( expr ) .)
    GREATER_THAN    reduce using rule 69 (expr -> ( expr ) .)
    LESS_THAN       reduce using rule 69 (expr -> ( expr ) .)
    GREATER_EQUAL   reduce using rule 69 (expr -> ( expr ) .)
    LESS_EQUAL      reduce using rule 69 (expr -> ( expr ) .)
    EQUAL           reduce using rule 69 (expr -> ( expr ) .)
    NOT_EQUAL       reduce using rule 69 (expr -> ( expr ) .)
    NUMBER          reduce using rule 69 (expr -> ( expr ) .)
    LETTER          reduce using rule 69 (expr -> ( expr ) .)
    SENTENCE        reduce using rule 69 (expr -> ( expr ) .)
    )               reduce using rule 69 (expr -> ( expr ) .)
    ,               reduce using rule 69 (expr -> ( expr ) .)
    .               reduce using rule 69 (expr -> ( expr ) .)
    AND             reduce using rule 69 (expr -> ( expr ) .)
    BUT             reduce using rule 69 (expr -> ( expr ) .)
    THEN            reduce using rule 69 (expr -> ( expr ) .)
    PIECE           reduce using rule 69 (expr -> ( expr ) .)
    BECAME          reduce using rule 69 (expr -> ( expr ) .)
    ATE             reduce using rule 69 (expr -> ( expr ) .)
    DRANK           reduce using rule 69 (expr -> ( expr ) .)
    SPOKE           reduce using rule 69 (expr -> ( expr ) .)
    SAID            reduce using rule 69 (expr -> ( expr ) .)
    ?               reduce using rule 69 (expr -> ( expr ) .)


state 76

    (71) actualParams -> ( actualParamsList . )
    (74) actualParamsList -> actualParamsList . , expr

    )               shift and go to state 106
    ,               shift and go to state 107


state 77

    (72) actualParams -> ( ) .

    .               reduce using rule 72 (actualParams -> ( ) .)
    ,               reduce using rule 72 (actualParams -> ( ) .)
    AND             reduce using rule 72 (actualParams -> ( ) .)
    BUT             reduce using rule 72 (actualParams -> ( ) .)
    THEN            reduce using rule 72 (actualParams -> ( ) .)
    BECAME          reduce using rule 72 (actualParams -> ( ) .)
    ATE             reduce using rule 72 (actualParams -> ( ) .)
    DRANK           reduce using rule 72 (actualParams -> ( ) .)
    SPOKE           reduce using rule 72 (actualParams -> ( ) .)
    SAID            reduce using rule 72 (actualParams -> ( ) .)
    +               reduce using rule 72 (actualParams -> ( ) .)
    -               reduce using rule 72 (actualParams -> ( ) .)
    *               reduce using rule 72 (actualParams -> ( ) .)
    /               reduce using rule 72 (actualParams -> ( ) .)
    %               reduce using rule 72 (actualParams -> ( ) .)
    &               reduce using rule 72 (actualParams -> ( ) .)
    |               reduce using rule 72 (actualParams -> ( ) .)
    ^               reduce using rule 72 (actualParams -> ( ) .)
    LOGICAL_OR      reduce using rule 72 (actualParams -> ( ) .)
    LOGICAL_AND     reduce using rule 72 (actualParams -> ( ) .)
    GREATER_THAN    reduce using rule 72 (actualParams -> ( ) .)
    LESS_THAN       reduce using rule 72 (actualParams -> ( ) .)
    GREATER_EQUAL   reduce using rule 72 (actualParams -> ( ) .)
    LESS_EQUAL      reduce using rule 72 (actualParams -> ( ) .)
    EQUAL           reduce using rule 72 (actualParams -> ( ) .)
    NOT_EQUAL       reduce using rule 72 (actualParams -> ( ) .)
    NUMBER          reduce using rule 72 (actualParams -> ( ) .)
    LETTER          reduce using rule 72 (actualParams -> ( ) .)
    SENTENCE        reduce using rule 72 (actualParams -> ( ) .)
    )               reduce using rule 72 (actualParams -> ( ) .)
    PIECE           reduce using rule 72 (actualParams -> ( ) .)
    ?               reduce using rule 72 (actualParams -> ( ) .)


state 78

    (73) actualParamsList -> expr .
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    )               reduce using rule 73 (actualParamsList -> expr .)
    ,               reduce using rule 73 (actualParamsList -> expr .)
    +               shift and go to state 48
    -               shift and go to state 50
    *               shift and go to state 49
    /               shift and go to state 51
    %               shift and go to state 45
    &               shift and go to state 47
    |               shift and go to state 57
    ^               shift and go to state 55
    LOGICAL_OR      shift and go to state 56
    LOGICAL_AND     shift and go to state 42
    GREATER_THAN    shift and go to state 41
    LESS_THAN       shift and go to state 43
    GREATER_EQUAL   shift and go to state 46
    LESS_EQUAL      shift and go to state 54
    EQUAL           shift and go to state 53
    NOT_EQUAL       shift and go to state 44


state 79

    (65) expr -> ID APOSTROPHE S . expr PIECE
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 108

state 80

    (54) expr -> expr GREATER_THAN expr .
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    &               reduce using rule 54 (expr -> expr GREATER_THAN expr .)
    |               reduce using rule 54 (expr -> expr GREATER_THAN expr .)
    ^               reduce using rule 54 (expr -> expr GREATER_THAN expr .)
    LOGICAL_OR      reduce using rule 54 (expr -> expr GREATER_THAN expr .)
    LOGICAL_AND     reduce using rule 54 (expr -> expr GREATER_THAN expr .)
    GREATER_THAN    reduce using rule 54 (expr -> expr GREATER_THAN expr .)
    LESS_THAN       reduce using rule 54 (expr -> expr GREATER_THAN expr .)
    GREATER_EQUAL   reduce using rule 54 (expr -> expr GREATER_THAN expr .)
    LESS_EQUAL      reduce using rule 54 (expr -> expr GREATER_THAN expr .)
    EQUAL           reduce using rule 54 (expr -> expr GREATER_THAN expr .)
    NOT_EQUAL       reduce using rule 54 (expr -> expr GREATER_THAN expr .)
    NUMBER          reduce using rule 54 (expr -> expr GREATER_THAN expr .)
    LETTER          reduce using rule 54 (expr -> expr GREATER_THAN expr .)
    SENTENCE        reduce using rule 54 (expr -> expr GREATER_THAN expr .)
    )               reduce using rule 54 (expr -> expr GREATER_THAN expr .)
    ,               reduce using rule 54 (expr -> expr GREATER_THAN expr .)
    .               reduce using rule 54 (expr -> expr GREATER_THAN expr .)
    AND             reduce using rule 54 (expr -> expr GREATER_THAN expr .)
    BUT             reduce using rule 54 (expr -> expr GREATER_THAN expr .)
    THEN            reduce using rule 54 (expr -> expr GREATER_THAN expr .)
    PIECE           reduce using rule 54 (expr -> expr GREATER_THAN expr .)
    BECAME          reduce using rule 54 (expr -> expr GREATER_THAN expr .)
    ATE             reduce using rule 54 (expr -> expr GREATER_THAN expr .)
    DRANK           reduce using rule 54 (expr -> expr GREATER_THAN expr .)
    SPOKE           reduce using rule 54 (expr -> expr GREATER_THAN expr .)
    SAID            reduce using rule 54 (expr -> expr GREATER_THAN expr .)
    ?               reduce using rule 54 (expr -> expr GREATER_THAN expr .)
    +               shift and go to state 48
    -               shift and go to state 50
    *               shift and go to state 49
    /               shift and go to state 51
    %               shift and go to state 45

  ! +               [ reduce using rule 54 (expr -> expr GREATER_THAN expr .) ]
  ! -               [ reduce using rule 54 (expr -> expr GREATER_THAN expr .) ]
  ! *               [ reduce using rule 54 (expr -> expr GREATER_THAN expr .) ]
  ! /               [ reduce using rule 54 (expr -> expr GREATER_THAN expr .) ]
  ! %               [ reduce using rule 54 (expr -> expr GREATER_THAN expr .) ]
  ! &               [ shift and go to state 47 ]
  ! |               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 55 ]
  ! LOGICAL_OR      [ shift and go to state 56 ]
  ! LOGICAL_AND     [ shift and go to state 42 ]
  ! GREATER_THAN    [ shift and go to state 41 ]
  ! LESS_THAN       [ shift and go to state 43 ]
  ! GREATER_EQUAL   [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 54 ]
  ! EQUAL           [ shift and go to state 53 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]


state 81

    (53) expr -> expr LOGICAL_AND expr .
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    LOGICAL_OR      reduce using rule 53 (expr -> expr LOGICAL_AND expr .)
    LOGICAL_AND     reduce using rule 53 (expr -> expr LOGICAL_AND expr .)
    NUMBER          reduce using rule 53 (expr -> expr LOGICAL_AND expr .)
    LETTER          reduce using rule 53 (expr -> expr LOGICAL_AND expr .)
    SENTENCE        reduce using rule 53 (expr -> expr LOGICAL_AND expr .)
    )               reduce using rule 53 (expr -> expr LOGICAL_AND expr .)
    ,               reduce using rule 53 (expr -> expr LOGICAL_AND expr .)
    .               reduce using rule 53 (expr -> expr LOGICAL_AND expr .)
    AND             reduce using rule 53 (expr -> expr LOGICAL_AND expr .)
    BUT             reduce using rule 53 (expr -> expr LOGICAL_AND expr .)
    THEN            reduce using rule 53 (expr -> expr LOGICAL_AND expr .)
    PIECE           reduce using rule 53 (expr -> expr LOGICAL_AND expr .)
    BECAME          reduce using rule 53 (expr -> expr LOGICAL_AND expr .)
    ATE             reduce using rule 53 (expr -> expr LOGICAL_AND expr .)
    DRANK           reduce using rule 53 (expr -> expr LOGICAL_AND expr .)
    SPOKE           reduce using rule 53 (expr -> expr LOGICAL_AND expr .)
    SAID            reduce using rule 53 (expr -> expr LOGICAL_AND expr .)
    ?               reduce using rule 53 (expr -> expr LOGICAL_AND expr .)
    +               shift and go to state 48
    -               shift and go to state 50
    *               shift and go to state 49
    /               shift and go to state 51
    %               shift and go to state 45
    &               shift and go to state 47
    |               shift and go to state 57
    ^               shift and go to state 55
    GREATER_THAN    shift and go to state 41
    LESS_THAN       shift and go to state 43
    GREATER_EQUAL   shift and go to state 46
    LESS_EQUAL      shift and go to state 54
    EQUAL           shift and go to state 53
    NOT_EQUAL       shift and go to state 44

  ! +               [ reduce using rule 53 (expr -> expr LOGICAL_AND expr .) ]
  ! -               [ reduce using rule 53 (expr -> expr LOGICAL_AND expr .) ]
  ! *               [ reduce using rule 53 (expr -> expr LOGICAL_AND expr .) ]
  ! /               [ reduce using rule 53 (expr -> expr LOGICAL_AND expr .) ]
  ! %               [ reduce using rule 53 (expr -> expr LOGICAL_AND expr .) ]
  ! &               [ reduce using rule 53 (expr -> expr LOGICAL_AND expr .) ]
  ! |               [ reduce using rule 53 (expr -> expr LOGICAL_AND expr .) ]
  ! ^               [ reduce using rule 53 (expr -> expr LOGICAL_AND expr .) ]
  ! GREATER_THAN    [ reduce using rule 53 (expr -> expr LOGICAL_AND expr .) ]
  ! LESS_THAN       [ reduce using rule 53 (expr -> expr LOGICAL_AND expr .) ]
  ! GREATER_EQUAL   [ reduce using rule 53 (expr -> expr LOGICAL_AND expr .) ]
  ! LESS_EQUAL      [ reduce using rule 53 (expr -> expr LOGICAL_AND expr .) ]
  ! EQUAL           [ reduce using rule 53 (expr -> expr LOGICAL_AND expr .) ]
  ! NOT_EQUAL       [ reduce using rule 53 (expr -> expr LOGICAL_AND expr .) ]
  ! LOGICAL_OR      [ shift and go to state 56 ]
  ! LOGICAL_AND     [ shift and go to state 42 ]


state 82

    (55) expr -> expr LESS_THAN expr .
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    &               reduce using rule 55 (expr -> expr LESS_THAN expr .)
    |               reduce using rule 55 (expr -> expr LESS_THAN expr .)
    ^               reduce using rule 55 (expr -> expr LESS_THAN expr .)
    LOGICAL_OR      reduce using rule 55 (expr -> expr LESS_THAN expr .)
    LOGICAL_AND     reduce using rule 55 (expr -> expr LESS_THAN expr .)
    GREATER_THAN    reduce using rule 55 (expr -> expr LESS_THAN expr .)
    LESS_THAN       reduce using rule 55 (expr -> expr LESS_THAN expr .)
    GREATER_EQUAL   reduce using rule 55 (expr -> expr LESS_THAN expr .)
    LESS_EQUAL      reduce using rule 55 (expr -> expr LESS_THAN expr .)
    EQUAL           reduce using rule 55 (expr -> expr LESS_THAN expr .)
    NOT_EQUAL       reduce using rule 55 (expr -> expr LESS_THAN expr .)
    NUMBER          reduce using rule 55 (expr -> expr LESS_THAN expr .)
    LETTER          reduce using rule 55 (expr -> expr LESS_THAN expr .)
    SENTENCE        reduce using rule 55 (expr -> expr LESS_THAN expr .)
    )               reduce using rule 55 (expr -> expr LESS_THAN expr .)
    ,               reduce using rule 55 (expr -> expr LESS_THAN expr .)
    .               reduce using rule 55 (expr -> expr LESS_THAN expr .)
    AND             reduce using rule 55 (expr -> expr LESS_THAN expr .)
    BUT             reduce using rule 55 (expr -> expr LESS_THAN expr .)
    THEN            reduce using rule 55 (expr -> expr LESS_THAN expr .)
    PIECE           reduce using rule 55 (expr -> expr LESS_THAN expr .)
    BECAME          reduce using rule 55 (expr -> expr LESS_THAN expr .)
    ATE             reduce using rule 55 (expr -> expr LESS_THAN expr .)
    DRANK           reduce using rule 55 (expr -> expr LESS_THAN expr .)
    SPOKE           reduce using rule 55 (expr -> expr LESS_THAN expr .)
    SAID            reduce using rule 55 (expr -> expr LESS_THAN expr .)
    ?               reduce using rule 55 (expr -> expr LESS_THAN expr .)
    +               shift and go to state 48
    -               shift and go to state 50
    *               shift and go to state 49
    /               shift and go to state 51
    %               shift and go to state 45

  ! +               [ reduce using rule 55 (expr -> expr LESS_THAN expr .) ]
  ! -               [ reduce using rule 55 (expr -> expr LESS_THAN expr .) ]
  ! *               [ reduce using rule 55 (expr -> expr LESS_THAN expr .) ]
  ! /               [ reduce using rule 55 (expr -> expr LESS_THAN expr .) ]
  ! %               [ reduce using rule 55 (expr -> expr LESS_THAN expr .) ]
  ! &               [ shift and go to state 47 ]
  ! |               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 55 ]
  ! LOGICAL_OR      [ shift and go to state 56 ]
  ! LOGICAL_AND     [ shift and go to state 42 ]
  ! GREATER_THAN    [ shift and go to state 41 ]
  ! LESS_THAN       [ shift and go to state 43 ]
  ! GREATER_EQUAL   [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 54 ]
  ! EQUAL           [ shift and go to state 53 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]


state 83

    (59) expr -> expr NOT_EQUAL expr .
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    &               reduce using rule 59 (expr -> expr NOT_EQUAL expr .)
    |               reduce using rule 59 (expr -> expr NOT_EQUAL expr .)
    ^               reduce using rule 59 (expr -> expr NOT_EQUAL expr .)
    LOGICAL_OR      reduce using rule 59 (expr -> expr NOT_EQUAL expr .)
    LOGICAL_AND     reduce using rule 59 (expr -> expr NOT_EQUAL expr .)
    EQUAL           reduce using rule 59 (expr -> expr NOT_EQUAL expr .)
    NOT_EQUAL       reduce using rule 59 (expr -> expr NOT_EQUAL expr .)
    NUMBER          reduce using rule 59 (expr -> expr NOT_EQUAL expr .)
    LETTER          reduce using rule 59 (expr -> expr NOT_EQUAL expr .)
    SENTENCE        reduce using rule 59 (expr -> expr NOT_EQUAL expr .)
    )               reduce using rule 59 (expr -> expr NOT_EQUAL expr .)
    ,               reduce using rule 59 (expr -> expr NOT_EQUAL expr .)
    .               reduce using rule 59 (expr -> expr NOT_EQUAL expr .)
    AND             reduce using rule 59 (expr -> expr NOT_EQUAL expr .)
    BUT             reduce using rule 59 (expr -> expr NOT_EQUAL expr .)
    THEN            reduce using rule 59 (expr -> expr NOT_EQUAL expr .)
    PIECE           reduce using rule 59 (expr -> expr NOT_EQUAL expr .)
    BECAME          reduce using rule 59 (expr -> expr NOT_EQUAL expr .)
    ATE             reduce using rule 59 (expr -> expr NOT_EQUAL expr .)
    DRANK           reduce using rule 59 (expr -> expr NOT_EQUAL expr .)
    SPOKE           reduce using rule 59 (expr -> expr NOT_EQUAL expr .)
    SAID            reduce using rule 59 (expr -> expr NOT_EQUAL expr .)
    ?               reduce using rule 59 (expr -> expr NOT_EQUAL expr .)
    +               shift and go to state 48
    -               shift and go to state 50
    *               shift and go to state 49
    /               shift and go to state 51
    %               shift and go to state 45
    GREATER_THAN    shift and go to state 41
    LESS_THAN       shift and go to state 43
    GREATER_EQUAL   shift and go to state 46
    LESS_EQUAL      shift and go to state 54

  ! +               [ reduce using rule 59 (expr -> expr NOT_EQUAL expr .) ]
  ! -               [ reduce using rule 59 (expr -> expr NOT_EQUAL expr .) ]
  ! *               [ reduce using rule 59 (expr -> expr NOT_EQUAL expr .) ]
  ! /               [ reduce using rule 59 (expr -> expr NOT_EQUAL expr .) ]
  ! %               [ reduce using rule 59 (expr -> expr NOT_EQUAL expr .) ]
  ! GREATER_THAN    [ reduce using rule 59 (expr -> expr NOT_EQUAL expr .) ]
  ! LESS_THAN       [ reduce using rule 59 (expr -> expr NOT_EQUAL expr .) ]
  ! GREATER_EQUAL   [ reduce using rule 59 (expr -> expr NOT_EQUAL expr .) ]
  ! LESS_EQUAL      [ reduce using rule 59 (expr -> expr NOT_EQUAL expr .) ]
  ! &               [ shift and go to state 47 ]
  ! |               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 55 ]
  ! LOGICAL_OR      [ shift and go to state 56 ]
  ! LOGICAL_AND     [ shift and go to state 42 ]
  ! EQUAL           [ shift and go to state 53 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]


state 84

    (48) expr -> expr % expr .
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    +               reduce using rule 48 (expr -> expr % expr .)
    -               reduce using rule 48 (expr -> expr % expr .)
    *               reduce using rule 48 (expr -> expr % expr .)
    /               reduce using rule 48 (expr -> expr % expr .)
    %               reduce using rule 48 (expr -> expr % expr .)
    &               reduce using rule 48 (expr -> expr % expr .)
    |               reduce using rule 48 (expr -> expr % expr .)
    ^               reduce using rule 48 (expr -> expr % expr .)
    LOGICAL_OR      reduce using rule 48 (expr -> expr % expr .)
    LOGICAL_AND     reduce using rule 48 (expr -> expr % expr .)
    GREATER_THAN    reduce using rule 48 (expr -> expr % expr .)
    LESS_THAN       reduce using rule 48 (expr -> expr % expr .)
    GREATER_EQUAL   reduce using rule 48 (expr -> expr % expr .)
    LESS_EQUAL      reduce using rule 48 (expr -> expr % expr .)
    EQUAL           reduce using rule 48 (expr -> expr % expr .)
    NOT_EQUAL       reduce using rule 48 (expr -> expr % expr .)
    NUMBER          reduce using rule 48 (expr -> expr % expr .)
    LETTER          reduce using rule 48 (expr -> expr % expr .)
    SENTENCE        reduce using rule 48 (expr -> expr % expr .)
    )               reduce using rule 48 (expr -> expr % expr .)
    ,               reduce using rule 48 (expr -> expr % expr .)
    .               reduce using rule 48 (expr -> expr % expr .)
    AND             reduce using rule 48 (expr -> expr % expr .)
    BUT             reduce using rule 48 (expr -> expr % expr .)
    THEN            reduce using rule 48 (expr -> expr % expr .)
    PIECE           reduce using rule 48 (expr -> expr % expr .)
    BECAME          reduce using rule 48 (expr -> expr % expr .)
    ATE             reduce using rule 48 (expr -> expr % expr .)
    DRANK           reduce using rule 48 (expr -> expr % expr .)
    SPOKE           reduce using rule 48 (expr -> expr % expr .)
    SAID            reduce using rule 48 (expr -> expr % expr .)
    ?               reduce using rule 48 (expr -> expr % expr .)

  ! +               [ shift and go to state 48 ]
  ! -               [ shift and go to state 50 ]
  ! *               [ shift and go to state 49 ]
  ! /               [ shift and go to state 51 ]
  ! %               [ shift and go to state 45 ]
  ! &               [ shift and go to state 47 ]
  ! |               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 55 ]
  ! LOGICAL_OR      [ shift and go to state 56 ]
  ! LOGICAL_AND     [ shift and go to state 42 ]
  ! GREATER_THAN    [ shift and go to state 41 ]
  ! LESS_THAN       [ shift and go to state 43 ]
  ! GREATER_EQUAL   [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 54 ]
  ! EQUAL           [ shift and go to state 53 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]


state 85

    (56) expr -> expr GREATER_EQUAL expr .
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    &               reduce using rule 56 (expr -> expr GREATER_EQUAL expr .)
    |               reduce using rule 56 (expr -> expr GREATER_EQUAL expr .)
    ^               reduce using rule 56 (expr -> expr GREATER_EQUAL expr .)
    LOGICAL_OR      reduce using rule 56 (expr -> expr GREATER_EQUAL expr .)
    LOGICAL_AND     reduce using rule 56 (expr -> expr GREATER_EQUAL expr .)
    GREATER_THAN    reduce using rule 56 (expr -> expr GREATER_EQUAL expr .)
    LESS_THAN       reduce using rule 56 (expr -> expr GREATER_EQUAL expr .)
    GREATER_EQUAL   reduce using rule 56 (expr -> expr GREATER_EQUAL expr .)
    LESS_EQUAL      reduce using rule 56 (expr -> expr GREATER_EQUAL expr .)
    EQUAL           reduce using rule 56 (expr -> expr GREATER_EQUAL expr .)
    NOT_EQUAL       reduce using rule 56 (expr -> expr GREATER_EQUAL expr .)
    NUMBER          reduce using rule 56 (expr -> expr GREATER_EQUAL expr .)
    LETTER          reduce using rule 56 (expr -> expr GREATER_EQUAL expr .)
    SENTENCE        reduce using rule 56 (expr -> expr GREATER_EQUAL expr .)
    )               reduce using rule 56 (expr -> expr GREATER_EQUAL expr .)
    ,               reduce using rule 56 (expr -> expr GREATER_EQUAL expr .)
    .               reduce using rule 56 (expr -> expr GREATER_EQUAL expr .)
    AND             reduce using rule 56 (expr -> expr GREATER_EQUAL expr .)
    BUT             reduce using rule 56 (expr -> expr GREATER_EQUAL expr .)
    THEN            reduce using rule 56 (expr -> expr GREATER_EQUAL expr .)
    PIECE           reduce using rule 56 (expr -> expr GREATER_EQUAL expr .)
    BECAME          reduce using rule 56 (expr -> expr GREATER_EQUAL expr .)
    ATE             reduce using rule 56 (expr -> expr GREATER_EQUAL expr .)
    DRANK           reduce using rule 56 (expr -> expr GREATER_EQUAL expr .)
    SPOKE           reduce using rule 56 (expr -> expr GREATER_EQUAL expr .)
    SAID            reduce using rule 56 (expr -> expr GREATER_EQUAL expr .)
    ?               reduce using rule 56 (expr -> expr GREATER_EQUAL expr .)
    +               shift and go to state 48
    -               shift and go to state 50
    *               shift and go to state 49
    /               shift and go to state 51
    %               shift and go to state 45

  ! +               [ reduce using rule 56 (expr -> expr GREATER_EQUAL expr .) ]
  ! -               [ reduce using rule 56 (expr -> expr GREATER_EQUAL expr .) ]
  ! *               [ reduce using rule 56 (expr -> expr GREATER_EQUAL expr .) ]
  ! /               [ reduce using rule 56 (expr -> expr GREATER_EQUAL expr .) ]
  ! %               [ reduce using rule 56 (expr -> expr GREATER_EQUAL expr .) ]
  ! &               [ shift and go to state 47 ]
  ! |               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 55 ]
  ! LOGICAL_OR      [ shift and go to state 56 ]
  ! LOGICAL_AND     [ shift and go to state 42 ]
  ! GREATER_THAN    [ shift and go to state 41 ]
  ! LESS_THAN       [ shift and go to state 43 ]
  ! GREATER_EQUAL   [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 54 ]
  ! EQUAL           [ shift and go to state 53 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]


state 86

    (49) expr -> expr & expr .
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    &               reduce using rule 49 (expr -> expr & expr .)
    |               reduce using rule 49 (expr -> expr & expr .)
    ^               reduce using rule 49 (expr -> expr & expr .)
    LOGICAL_OR      reduce using rule 49 (expr -> expr & expr .)
    LOGICAL_AND     reduce using rule 49 (expr -> expr & expr .)
    NUMBER          reduce using rule 49 (expr -> expr & expr .)
    LETTER          reduce using rule 49 (expr -> expr & expr .)
    SENTENCE        reduce using rule 49 (expr -> expr & expr .)
    )               reduce using rule 49 (expr -> expr & expr .)
    ,               reduce using rule 49 (expr -> expr & expr .)
    .               reduce using rule 49 (expr -> expr & expr .)
    AND             reduce using rule 49 (expr -> expr & expr .)
    BUT             reduce using rule 49 (expr -> expr & expr .)
    THEN            reduce using rule 49 (expr -> expr & expr .)
    PIECE           reduce using rule 49 (expr -> expr & expr .)
    BECAME          reduce using rule 49 (expr -> expr & expr .)
    ATE             reduce using rule 49 (expr -> expr & expr .)
    DRANK           reduce using rule 49 (expr -> expr & expr .)
    SPOKE           reduce using rule 49 (expr -> expr & expr .)
    SAID            reduce using rule 49 (expr -> expr & expr .)
    ?               reduce using rule 49 (expr -> expr & expr .)
    +               shift and go to state 48
    -               shift and go to state 50
    *               shift and go to state 49
    /               shift and go to state 51
    %               shift and go to state 45
    GREATER_THAN    shift and go to state 41
    LESS_THAN       shift and go to state 43
    GREATER_EQUAL   shift and go to state 46
    LESS_EQUAL      shift and go to state 54
    EQUAL           shift and go to state 53
    NOT_EQUAL       shift and go to state 44

  ! +               [ reduce using rule 49 (expr -> expr & expr .) ]
  ! -               [ reduce using rule 49 (expr -> expr & expr .) ]
  ! *               [ reduce using rule 49 (expr -> expr & expr .) ]
  ! /               [ reduce using rule 49 (expr -> expr & expr .) ]
  ! %               [ reduce using rule 49 (expr -> expr & expr .) ]
  ! GREATER_THAN    [ reduce using rule 49 (expr -> expr & expr .) ]
  ! LESS_THAN       [ reduce using rule 49 (expr -> expr & expr .) ]
  ! GREATER_EQUAL   [ reduce using rule 49 (expr -> expr & expr .) ]
  ! LESS_EQUAL      [ reduce using rule 49 (expr -> expr & expr .) ]
  ! EQUAL           [ reduce using rule 49 (expr -> expr & expr .) ]
  ! NOT_EQUAL       [ reduce using rule 49 (expr -> expr & expr .) ]
  ! &               [ shift and go to state 47 ]
  ! |               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 55 ]
  ! LOGICAL_OR      [ shift and go to state 56 ]
  ! LOGICAL_AND     [ shift and go to state 42 ]


state 87

    (44) expr -> expr + expr .
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    +               reduce using rule 44 (expr -> expr + expr .)
    -               reduce using rule 44 (expr -> expr + expr .)
    &               reduce using rule 44 (expr -> expr + expr .)
    |               reduce using rule 44 (expr -> expr + expr .)
    ^               reduce using rule 44 (expr -> expr + expr .)
    LOGICAL_OR      reduce using rule 44 (expr -> expr + expr .)
    LOGICAL_AND     reduce using rule 44 (expr -> expr + expr .)
    GREATER_THAN    reduce using rule 44 (expr -> expr + expr .)
    LESS_THAN       reduce using rule 44 (expr -> expr + expr .)
    GREATER_EQUAL   reduce using rule 44 (expr -> expr + expr .)
    LESS_EQUAL      reduce using rule 44 (expr -> expr + expr .)
    EQUAL           reduce using rule 44 (expr -> expr + expr .)
    NOT_EQUAL       reduce using rule 44 (expr -> expr + expr .)
    NUMBER          reduce using rule 44 (expr -> expr + expr .)
    LETTER          reduce using rule 44 (expr -> expr + expr .)
    SENTENCE        reduce using rule 44 (expr -> expr + expr .)
    )               reduce using rule 44 (expr -> expr + expr .)
    ,               reduce using rule 44 (expr -> expr + expr .)
    .               reduce using rule 44 (expr -> expr + expr .)
    AND             reduce using rule 44 (expr -> expr + expr .)
    BUT             reduce using rule 44 (expr -> expr + expr .)
    THEN            reduce using rule 44 (expr -> expr + expr .)
    PIECE           reduce using rule 44 (expr -> expr + expr .)
    BECAME          reduce using rule 44 (expr -> expr + expr .)
    ATE             reduce using rule 44 (expr -> expr + expr .)
    DRANK           reduce using rule 44 (expr -> expr + expr .)
    SPOKE           reduce using rule 44 (expr -> expr + expr .)
    SAID            reduce using rule 44 (expr -> expr + expr .)
    ?               reduce using rule 44 (expr -> expr + expr .)
    *               shift and go to state 49
    /               shift and go to state 51
    %               shift and go to state 45

  ! *               [ reduce using rule 44 (expr -> expr + expr .) ]
  ! /               [ reduce using rule 44 (expr -> expr + expr .) ]
  ! %               [ reduce using rule 44 (expr -> expr + expr .) ]
  ! +               [ shift and go to state 48 ]
  ! -               [ shift and go to state 50 ]
  ! &               [ shift and go to state 47 ]
  ! |               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 55 ]
  ! LOGICAL_OR      [ shift and go to state 56 ]
  ! LOGICAL_AND     [ shift and go to state 42 ]
  ! GREATER_THAN    [ shift and go to state 41 ]
  ! LESS_THAN       [ shift and go to state 43 ]
  ! GREATER_EQUAL   [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 54 ]
  ! EQUAL           [ shift and go to state 53 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]


state 88

    (46) expr -> expr * expr .
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    +               reduce using rule 46 (expr -> expr * expr .)
    -               reduce using rule 46 (expr -> expr * expr .)
    *               reduce using rule 46 (expr -> expr * expr .)
    /               reduce using rule 46 (expr -> expr * expr .)
    %               reduce using rule 46 (expr -> expr * expr .)
    &               reduce using rule 46 (expr -> expr * expr .)
    |               reduce using rule 46 (expr -> expr * expr .)
    ^               reduce using rule 46 (expr -> expr * expr .)
    LOGICAL_OR      reduce using rule 46 (expr -> expr * expr .)
    LOGICAL_AND     reduce using rule 46 (expr -> expr * expr .)
    GREATER_THAN    reduce using rule 46 (expr -> expr * expr .)
    LESS_THAN       reduce using rule 46 (expr -> expr * expr .)
    GREATER_EQUAL   reduce using rule 46 (expr -> expr * expr .)
    LESS_EQUAL      reduce using rule 46 (expr -> expr * expr .)
    EQUAL           reduce using rule 46 (expr -> expr * expr .)
    NOT_EQUAL       reduce using rule 46 (expr -> expr * expr .)
    NUMBER          reduce using rule 46 (expr -> expr * expr .)
    LETTER          reduce using rule 46 (expr -> expr * expr .)
    SENTENCE        reduce using rule 46 (expr -> expr * expr .)
    )               reduce using rule 46 (expr -> expr * expr .)
    ,               reduce using rule 46 (expr -> expr * expr .)
    .               reduce using rule 46 (expr -> expr * expr .)
    AND             reduce using rule 46 (expr -> expr * expr .)
    BUT             reduce using rule 46 (expr -> expr * expr .)
    THEN            reduce using rule 46 (expr -> expr * expr .)
    PIECE           reduce using rule 46 (expr -> expr * expr .)
    BECAME          reduce using rule 46 (expr -> expr * expr .)
    ATE             reduce using rule 46 (expr -> expr * expr .)
    DRANK           reduce using rule 46 (expr -> expr * expr .)
    SPOKE           reduce using rule 46 (expr -> expr * expr .)
    SAID            reduce using rule 46 (expr -> expr * expr .)
    ?               reduce using rule 46 (expr -> expr * expr .)

  ! +               [ shift and go to state 48 ]
  ! -               [ shift and go to state 50 ]
  ! *               [ shift and go to state 49 ]
  ! /               [ shift and go to state 51 ]
  ! %               [ shift and go to state 45 ]
  ! &               [ shift and go to state 47 ]
  ! |               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 55 ]
  ! LOGICAL_OR      [ shift and go to state 56 ]
  ! LOGICAL_AND     [ shift and go to state 42 ]
  ! GREATER_THAN    [ shift and go to state 41 ]
  ! LESS_THAN       [ shift and go to state 43 ]
  ! GREATER_EQUAL   [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 54 ]
  ! EQUAL           [ shift and go to state 53 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]


state 89

    (45) expr -> expr - expr .
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    +               reduce using rule 45 (expr -> expr - expr .)
    -               reduce using rule 45 (expr -> expr - expr .)
    &               reduce using rule 45 (expr -> expr - expr .)
    |               reduce using rule 45 (expr -> expr - expr .)
    ^               reduce using rule 45 (expr -> expr - expr .)
    LOGICAL_OR      reduce using rule 45 (expr -> expr - expr .)
    LOGICAL_AND     reduce using rule 45 (expr -> expr - expr .)
    GREATER_THAN    reduce using rule 45 (expr -> expr - expr .)
    LESS_THAN       reduce using rule 45 (expr -> expr - expr .)
    GREATER_EQUAL   reduce using rule 45 (expr -> expr - expr .)
    LESS_EQUAL      reduce using rule 45 (expr -> expr - expr .)
    EQUAL           reduce using rule 45 (expr -> expr - expr .)
    NOT_EQUAL       reduce using rule 45 (expr -> expr - expr .)
    NUMBER          reduce using rule 45 (expr -> expr - expr .)
    LETTER          reduce using rule 45 (expr -> expr - expr .)
    SENTENCE        reduce using rule 45 (expr -> expr - expr .)
    )               reduce using rule 45 (expr -> expr - expr .)
    ,               reduce using rule 45 (expr -> expr - expr .)
    .               reduce using rule 45 (expr -> expr - expr .)
    AND             reduce using rule 45 (expr -> expr - expr .)
    BUT             reduce using rule 45 (expr -> expr - expr .)
    THEN            reduce using rule 45 (expr -> expr - expr .)
    PIECE           reduce using rule 45 (expr -> expr - expr .)
    BECAME          reduce using rule 45 (expr -> expr - expr .)
    ATE             reduce using rule 45 (expr -> expr - expr .)
    DRANK           reduce using rule 45 (expr -> expr - expr .)
    SPOKE           reduce using rule 45 (expr -> expr - expr .)
    SAID            reduce using rule 45 (expr -> expr - expr .)
    ?               reduce using rule 45 (expr -> expr - expr .)
    *               shift and go to state 49
    /               shift and go to state 51
    %               shift and go to state 45

  ! *               [ reduce using rule 45 (expr -> expr - expr .) ]
  ! /               [ reduce using rule 45 (expr -> expr - expr .) ]
  ! %               [ reduce using rule 45 (expr -> expr - expr .) ]
  ! +               [ shift and go to state 48 ]
  ! -               [ shift and go to state 50 ]
  ! &               [ shift and go to state 47 ]
  ! |               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 55 ]
  ! LOGICAL_OR      [ shift and go to state 56 ]
  ! LOGICAL_AND     [ shift and go to state 42 ]
  ! GREATER_THAN    [ shift and go to state 41 ]
  ! LESS_THAN       [ shift and go to state 43 ]
  ! GREATER_EQUAL   [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 54 ]
  ! EQUAL           [ shift and go to state 53 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]


state 90

    (47) expr -> expr / expr .
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    +               reduce using rule 47 (expr -> expr / expr .)
    -               reduce using rule 47 (expr -> expr / expr .)
    *               reduce using rule 47 (expr -> expr / expr .)
    /               reduce using rule 47 (expr -> expr / expr .)
    %               reduce using rule 47 (expr -> expr / expr .)
    &               reduce using rule 47 (expr -> expr / expr .)
    |               reduce using rule 47 (expr -> expr / expr .)
    ^               reduce using rule 47 (expr -> expr / expr .)
    LOGICAL_OR      reduce using rule 47 (expr -> expr / expr .)
    LOGICAL_AND     reduce using rule 47 (expr -> expr / expr .)
    GREATER_THAN    reduce using rule 47 (expr -> expr / expr .)
    LESS_THAN       reduce using rule 47 (expr -> expr / expr .)
    GREATER_EQUAL   reduce using rule 47 (expr -> expr / expr .)
    LESS_EQUAL      reduce using rule 47 (expr -> expr / expr .)
    EQUAL           reduce using rule 47 (expr -> expr / expr .)
    NOT_EQUAL       reduce using rule 47 (expr -> expr / expr .)
    NUMBER          reduce using rule 47 (expr -> expr / expr .)
    LETTER          reduce using rule 47 (expr -> expr / expr .)
    SENTENCE        reduce using rule 47 (expr -> expr / expr .)
    )               reduce using rule 47 (expr -> expr / expr .)
    ,               reduce using rule 47 (expr -> expr / expr .)
    .               reduce using rule 47 (expr -> expr / expr .)
    AND             reduce using rule 47 (expr -> expr / expr .)
    BUT             reduce using rule 47 (expr -> expr / expr .)
    THEN            reduce using rule 47 (expr -> expr / expr .)
    PIECE           reduce using rule 47 (expr -> expr / expr .)
    BECAME          reduce using rule 47 (expr -> expr / expr .)
    ATE             reduce using rule 47 (expr -> expr / expr .)
    DRANK           reduce using rule 47 (expr -> expr / expr .)
    SPOKE           reduce using rule 47 (expr -> expr / expr .)
    SAID            reduce using rule 47 (expr -> expr / expr .)
    ?               reduce using rule 47 (expr -> expr / expr .)

  ! +               [ shift and go to state 48 ]
  ! -               [ shift and go to state 50 ]
  ! *               [ shift and go to state 49 ]
  ! /               [ shift and go to state 51 ]
  ! %               [ shift and go to state 45 ]
  ! &               [ shift and go to state 47 ]
  ! |               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 55 ]
  ! LOGICAL_OR      [ shift and go to state 56 ]
  ! LOGICAL_AND     [ shift and go to state 42 ]
  ! GREATER_THAN    [ shift and go to state 41 ]
  ! LESS_THAN       [ shift and go to state 43 ]
  ! GREATER_EQUAL   [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 54 ]
  ! EQUAL           [ shift and go to state 53 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]


state 91

    (10) varDecl -> ID HAD expr type terminator .

    ID              reduce using rule 10 (varDecl -> ID HAD expr type terminator .)
    THE             reduce using rule 10 (varDecl -> ID HAD expr type terminator .)
    $end            reduce using rule 10 (varDecl -> ID HAD expr type terminator .)
    .               reduce using rule 10 (varDecl -> ID HAD expr type terminator .)
    ALICE           reduce using rule 10 (varDecl -> ID HAD expr type terminator .)
    WHAT            reduce using rule 10 (varDecl -> ID HAD expr type terminator .)
    EVENTUALLY      reduce using rule 10 (varDecl -> ID HAD expr type terminator .)
    EITHER          reduce using rule 10 (varDecl -> ID HAD expr type terminator .)
    OPENED          reduce using rule 10 (varDecl -> ID HAD expr type terminator .)
    LOGICAL_NOT     reduce using rule 10 (varDecl -> ID HAD expr type terminator .)
    ~               reduce using rule 10 (varDecl -> ID HAD expr type terminator .)
    +               reduce using rule 10 (varDecl -> ID HAD expr type terminator .)
    -               reduce using rule 10 (varDecl -> ID HAD expr type terminator .)
    STRING_LITERAL  reduce using rule 10 (varDecl -> ID HAD expr type terminator .)
    CHAR_LITERAL    reduce using rule 10 (varDecl -> ID HAD expr type terminator .)
    INT_LITERAL     reduce using rule 10 (varDecl -> ID HAD expr type terminator .)
    (               reduce using rule 10 (varDecl -> ID HAD expr type terminator .)
    PERHAPS         reduce using rule 10 (varDecl -> ID HAD expr type terminator .)


state 92

    (58) expr -> expr EQUAL expr .
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    &               reduce using rule 58 (expr -> expr EQUAL expr .)
    |               reduce using rule 58 (expr -> expr EQUAL expr .)
    ^               reduce using rule 58 (expr -> expr EQUAL expr .)
    LOGICAL_OR      reduce using rule 58 (expr -> expr EQUAL expr .)
    LOGICAL_AND     reduce using rule 58 (expr -> expr EQUAL expr .)
    EQUAL           reduce using rule 58 (expr -> expr EQUAL expr .)
    NOT_EQUAL       reduce using rule 58 (expr -> expr EQUAL expr .)
    NUMBER          reduce using rule 58 (expr -> expr EQUAL expr .)
    LETTER          reduce using rule 58 (expr -> expr EQUAL expr .)
    SENTENCE        reduce using rule 58 (expr -> expr EQUAL expr .)
    )               reduce using rule 58 (expr -> expr EQUAL expr .)
    ,               reduce using rule 58 (expr -> expr EQUAL expr .)
    .               reduce using rule 58 (expr -> expr EQUAL expr .)
    AND             reduce using rule 58 (expr -> expr EQUAL expr .)
    BUT             reduce using rule 58 (expr -> expr EQUAL expr .)
    THEN            reduce using rule 58 (expr -> expr EQUAL expr .)
    PIECE           reduce using rule 58 (expr -> expr EQUAL expr .)
    BECAME          reduce using rule 58 (expr -> expr EQUAL expr .)
    ATE             reduce using rule 58 (expr -> expr EQUAL expr .)
    DRANK           reduce using rule 58 (expr -> expr EQUAL expr .)
    SPOKE           reduce using rule 58 (expr -> expr EQUAL expr .)
    SAID            reduce using rule 58 (expr -> expr EQUAL expr .)
    ?               reduce using rule 58 (expr -> expr EQUAL expr .)
    +               shift and go to state 48
    -               shift and go to state 50
    *               shift and go to state 49
    /               shift and go to state 51
    %               shift and go to state 45
    GREATER_THAN    shift and go to state 41
    LESS_THAN       shift and go to state 43
    GREATER_EQUAL   shift and go to state 46
    LESS_EQUAL      shift and go to state 54

  ! +               [ reduce using rule 58 (expr -> expr EQUAL expr .) ]
  ! -               [ reduce using rule 58 (expr -> expr EQUAL expr .) ]
  ! *               [ reduce using rule 58 (expr -> expr EQUAL expr .) ]
  ! /               [ reduce using rule 58 (expr -> expr EQUAL expr .) ]
  ! %               [ reduce using rule 58 (expr -> expr EQUAL expr .) ]
  ! GREATER_THAN    [ reduce using rule 58 (expr -> expr EQUAL expr .) ]
  ! LESS_THAN       [ reduce using rule 58 (expr -> expr EQUAL expr .) ]
  ! GREATER_EQUAL   [ reduce using rule 58 (expr -> expr EQUAL expr .) ]
  ! LESS_EQUAL      [ reduce using rule 58 (expr -> expr EQUAL expr .) ]
  ! &               [ shift and go to state 47 ]
  ! |               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 55 ]
  ! LOGICAL_OR      [ shift and go to state 56 ]
  ! LOGICAL_AND     [ shift and go to state 42 ]
  ! EQUAL           [ shift and go to state 53 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]


state 93

    (57) expr -> expr LESS_EQUAL expr .
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    &               reduce using rule 57 (expr -> expr LESS_EQUAL expr .)
    |               reduce using rule 57 (expr -> expr LESS_EQUAL expr .)
    ^               reduce using rule 57 (expr -> expr LESS_EQUAL expr .)
    LOGICAL_OR      reduce using rule 57 (expr -> expr LESS_EQUAL expr .)
    LOGICAL_AND     reduce using rule 57 (expr -> expr LESS_EQUAL expr .)
    GREATER_THAN    reduce using rule 57 (expr -> expr LESS_EQUAL expr .)
    LESS_THAN       reduce using rule 57 (expr -> expr LESS_EQUAL expr .)
    GREATER_EQUAL   reduce using rule 57 (expr -> expr LESS_EQUAL expr .)
    LESS_EQUAL      reduce using rule 57 (expr -> expr LESS_EQUAL expr .)
    EQUAL           reduce using rule 57 (expr -> expr LESS_EQUAL expr .)
    NOT_EQUAL       reduce using rule 57 (expr -> expr LESS_EQUAL expr .)
    NUMBER          reduce using rule 57 (expr -> expr LESS_EQUAL expr .)
    LETTER          reduce using rule 57 (expr -> expr LESS_EQUAL expr .)
    SENTENCE        reduce using rule 57 (expr -> expr LESS_EQUAL expr .)
    )               reduce using rule 57 (expr -> expr LESS_EQUAL expr .)
    ,               reduce using rule 57 (expr -> expr LESS_EQUAL expr .)
    .               reduce using rule 57 (expr -> expr LESS_EQUAL expr .)
    AND             reduce using rule 57 (expr -> expr LESS_EQUAL expr .)
    BUT             reduce using rule 57 (expr -> expr LESS_EQUAL expr .)
    THEN            reduce using rule 57 (expr -> expr LESS_EQUAL expr .)
    PIECE           reduce using rule 57 (expr -> expr LESS_EQUAL expr .)
    BECAME          reduce using rule 57 (expr -> expr LESS_EQUAL expr .)
    ATE             reduce using rule 57 (expr -> expr LESS_EQUAL expr .)
    DRANK           reduce using rule 57 (expr -> expr LESS_EQUAL expr .)
    SPOKE           reduce using rule 57 (expr -> expr LESS_EQUAL expr .)
    SAID            reduce using rule 57 (expr -> expr LESS_EQUAL expr .)
    ?               reduce using rule 57 (expr -> expr LESS_EQUAL expr .)
    +               shift and go to state 48
    -               shift and go to state 50
    *               shift and go to state 49
    /               shift and go to state 51
    %               shift and go to state 45

  ! +               [ reduce using rule 57 (expr -> expr LESS_EQUAL expr .) ]
  ! -               [ reduce using rule 57 (expr -> expr LESS_EQUAL expr .) ]
  ! *               [ reduce using rule 57 (expr -> expr LESS_EQUAL expr .) ]
  ! /               [ reduce using rule 57 (expr -> expr LESS_EQUAL expr .) ]
  ! %               [ reduce using rule 57 (expr -> expr LESS_EQUAL expr .) ]
  ! &               [ shift and go to state 47 ]
  ! |               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 55 ]
  ! LOGICAL_OR      [ shift and go to state 56 ]
  ! LOGICAL_AND     [ shift and go to state 42 ]
  ! GREATER_THAN    [ shift and go to state 41 ]
  ! LESS_THAN       [ shift and go to state 43 ]
  ! GREATER_EQUAL   [ shift and go to state 46 ]
  ! LESS_EQUAL      [ shift and go to state 54 ]
  ! EQUAL           [ shift and go to state 53 ]
  ! NOT_EQUAL       [ shift and go to state 44 ]


state 94

    (51) expr -> expr ^ expr .
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    |               reduce using rule 51 (expr -> expr ^ expr .)
    ^               reduce using rule 51 (expr -> expr ^ expr .)
    LOGICAL_OR      reduce using rule 51 (expr -> expr ^ expr .)
    LOGICAL_AND     reduce using rule 51 (expr -> expr ^ expr .)
    NUMBER          reduce using rule 51 (expr -> expr ^ expr .)
    LETTER          reduce using rule 51 (expr -> expr ^ expr .)
    SENTENCE        reduce using rule 51 (expr -> expr ^ expr .)
    )               reduce using rule 51 (expr -> expr ^ expr .)
    ,               reduce using rule 51 (expr -> expr ^ expr .)
    .               reduce using rule 51 (expr -> expr ^ expr .)
    AND             reduce using rule 51 (expr -> expr ^ expr .)
    BUT             reduce using rule 51 (expr -> expr ^ expr .)
    THEN            reduce using rule 51 (expr -> expr ^ expr .)
    PIECE           reduce using rule 51 (expr -> expr ^ expr .)
    BECAME          reduce using rule 51 (expr -> expr ^ expr .)
    ATE             reduce using rule 51 (expr -> expr ^ expr .)
    DRANK           reduce using rule 51 (expr -> expr ^ expr .)
    SPOKE           reduce using rule 51 (expr -> expr ^ expr .)
    SAID            reduce using rule 51 (expr -> expr ^ expr .)
    ?               reduce using rule 51 (expr -> expr ^ expr .)
    +               shift and go to state 48
    -               shift and go to state 50
    *               shift and go to state 49
    /               shift and go to state 51
    %               shift and go to state 45
    &               shift and go to state 47
    GREATER_THAN    shift and go to state 41
    LESS_THAN       shift and go to state 43
    GREATER_EQUAL   shift and go to state 46
    LESS_EQUAL      shift and go to state 54
    EQUAL           shift and go to state 53
    NOT_EQUAL       shift and go to state 44

  ! +               [ reduce using rule 51 (expr -> expr ^ expr .) ]
  ! -               [ reduce using rule 51 (expr -> expr ^ expr .) ]
  ! *               [ reduce using rule 51 (expr -> expr ^ expr .) ]
  ! /               [ reduce using rule 51 (expr -> expr ^ expr .) ]
  ! %               [ reduce using rule 51 (expr -> expr ^ expr .) ]
  ! &               [ reduce using rule 51 (expr -> expr ^ expr .) ]
  ! GREATER_THAN    [ reduce using rule 51 (expr -> expr ^ expr .) ]
  ! LESS_THAN       [ reduce using rule 51 (expr -> expr ^ expr .) ]
  ! GREATER_EQUAL   [ reduce using rule 51 (expr -> expr ^ expr .) ]
  ! LESS_EQUAL      [ reduce using rule 51 (expr -> expr ^ expr .) ]
  ! EQUAL           [ reduce using rule 51 (expr -> expr ^ expr .) ]
  ! NOT_EQUAL       [ reduce using rule 51 (expr -> expr ^ expr .) ]
  ! |               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 55 ]
  ! LOGICAL_OR      [ shift and go to state 56 ]
  ! LOGICAL_AND     [ shift and go to state 42 ]


state 95

    (52) expr -> expr LOGICAL_OR expr .
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    LOGICAL_OR      reduce using rule 52 (expr -> expr LOGICAL_OR expr .)
    NUMBER          reduce using rule 52 (expr -> expr LOGICAL_OR expr .)
    LETTER          reduce using rule 52 (expr -> expr LOGICAL_OR expr .)
    SENTENCE        reduce using rule 52 (expr -> expr LOGICAL_OR expr .)
    )               reduce using rule 52 (expr -> expr LOGICAL_OR expr .)
    ,               reduce using rule 52 (expr -> expr LOGICAL_OR expr .)
    .               reduce using rule 52 (expr -> expr LOGICAL_OR expr .)
    AND             reduce using rule 52 (expr -> expr LOGICAL_OR expr .)
    BUT             reduce using rule 52 (expr -> expr LOGICAL_OR expr .)
    THEN            reduce using rule 52 (expr -> expr LOGICAL_OR expr .)
    PIECE           reduce using rule 52 (expr -> expr LOGICAL_OR expr .)
    BECAME          reduce using rule 52 (expr -> expr LOGICAL_OR expr .)
    ATE             reduce using rule 52 (expr -> expr LOGICAL_OR expr .)
    DRANK           reduce using rule 52 (expr -> expr LOGICAL_OR expr .)
    SPOKE           reduce using rule 52 (expr -> expr LOGICAL_OR expr .)
    SAID            reduce using rule 52 (expr -> expr LOGICAL_OR expr .)
    ?               reduce using rule 52 (expr -> expr LOGICAL_OR expr .)
    +               shift and go to state 48
    -               shift and go to state 50
    *               shift and go to state 49
    /               shift and go to state 51
    %               shift and go to state 45
    &               shift and go to state 47
    |               shift and go to state 57
    ^               shift and go to state 55
    LOGICAL_AND     shift and go to state 42
    GREATER_THAN    shift and go to state 41
    LESS_THAN       shift and go to state 43
    GREATER_EQUAL   shift and go to state 46
    LESS_EQUAL      shift and go to state 54
    EQUAL           shift and go to state 53
    NOT_EQUAL       shift and go to state 44

  ! +               [ reduce using rule 52 (expr -> expr LOGICAL_OR expr .) ]
  ! -               [ reduce using rule 52 (expr -> expr LOGICAL_OR expr .) ]
  ! *               [ reduce using rule 52 (expr -> expr LOGICAL_OR expr .) ]
  ! /               [ reduce using rule 52 (expr -> expr LOGICAL_OR expr .) ]
  ! %               [ reduce using rule 52 (expr -> expr LOGICAL_OR expr .) ]
  ! &               [ reduce using rule 52 (expr -> expr LOGICAL_OR expr .) ]
  ! |               [ reduce using rule 52 (expr -> expr LOGICAL_OR expr .) ]
  ! ^               [ reduce using rule 52 (expr -> expr LOGICAL_OR expr .) ]
  ! LOGICAL_AND     [ reduce using rule 52 (expr -> expr LOGICAL_OR expr .) ]
  ! GREATER_THAN    [ reduce using rule 52 (expr -> expr LOGICAL_OR expr .) ]
  ! LESS_THAN       [ reduce using rule 52 (expr -> expr LOGICAL_OR expr .) ]
  ! GREATER_EQUAL   [ reduce using rule 52 (expr -> expr LOGICAL_OR expr .) ]
  ! LESS_EQUAL      [ reduce using rule 52 (expr -> expr LOGICAL_OR expr .) ]
  ! EQUAL           [ reduce using rule 52 (expr -> expr LOGICAL_OR expr .) ]
  ! NOT_EQUAL       [ reduce using rule 52 (expr -> expr LOGICAL_OR expr .) ]
  ! LOGICAL_OR      [ shift and go to state 56 ]


state 96

    (50) expr -> expr | expr .
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    |               reduce using rule 50 (expr -> expr | expr .)
    LOGICAL_OR      reduce using rule 50 (expr -> expr | expr .)
    LOGICAL_AND     reduce using rule 50 (expr -> expr | expr .)
    NUMBER          reduce using rule 50 (expr -> expr | expr .)
    LETTER          reduce using rule 50 (expr -> expr | expr .)
    SENTENCE        reduce using rule 50 (expr -> expr | expr .)
    )               reduce using rule 50 (expr -> expr | expr .)
    ,               reduce using rule 50 (expr -> expr | expr .)
    .               reduce using rule 50 (expr -> expr | expr .)
    AND             reduce using rule 50 (expr -> expr | expr .)
    BUT             reduce using rule 50 (expr -> expr | expr .)
    THEN            reduce using rule 50 (expr -> expr | expr .)
    PIECE           reduce using rule 50 (expr -> expr | expr .)
    BECAME          reduce using rule 50 (expr -> expr | expr .)
    ATE             reduce using rule 50 (expr -> expr | expr .)
    DRANK           reduce using rule 50 (expr -> expr | expr .)
    SPOKE           reduce using rule 50 (expr -> expr | expr .)
    SAID            reduce using rule 50 (expr -> expr | expr .)
    ?               reduce using rule 50 (expr -> expr | expr .)
    +               shift and go to state 48
    -               shift and go to state 50
    *               shift and go to state 49
    /               shift and go to state 51
    %               shift and go to state 45
    &               shift and go to state 47
    ^               shift and go to state 55
    GREATER_THAN    shift and go to state 41
    LESS_THAN       shift and go to state 43
    GREATER_EQUAL   shift and go to state 46
    LESS_EQUAL      shift and go to state 54
    EQUAL           shift and go to state 53
    NOT_EQUAL       shift and go to state 44

  ! +               [ reduce using rule 50 (expr -> expr | expr .) ]
  ! -               [ reduce using rule 50 (expr -> expr | expr .) ]
  ! *               [ reduce using rule 50 (expr -> expr | expr .) ]
  ! /               [ reduce using rule 50 (expr -> expr | expr .) ]
  ! %               [ reduce using rule 50 (expr -> expr | expr .) ]
  ! &               [ reduce using rule 50 (expr -> expr | expr .) ]
  ! ^               [ reduce using rule 50 (expr -> expr | expr .) ]
  ! GREATER_THAN    [ reduce using rule 50 (expr -> expr | expr .) ]
  ! LESS_THAN       [ reduce using rule 50 (expr -> expr | expr .) ]
  ! GREATER_EQUAL   [ reduce using rule 50 (expr -> expr | expr .) ]
  ! LESS_EQUAL      [ reduce using rule 50 (expr -> expr | expr .) ]
  ! EQUAL           [ reduce using rule 50 (expr -> expr | expr .) ]
  ! NOT_EQUAL       [ reduce using rule 50 (expr -> expr | expr .) ]
  ! |               [ shift and go to state 57 ]
  ! LOGICAL_OR      [ shift and go to state 56 ]
  ! LOGICAL_AND     [ shift and go to state 42 ]


state 97

    (18) formalParam -> refType ID .

    )               reduce using rule 18 (formalParam -> refType ID .)
    ,               reduce using rule 18 (formalParam -> refType ID .)


state 98

    (43) refType -> SPIDER type .

    ID              reduce using rule 43 (refType -> SPIDER type .)


state 99

    (17) formalParam -> type ID .

    )               reduce using rule 17 (formalParam -> type ID .)
    ,               reduce using rule 17 (formalParam -> type ID .)


state 100

    (14) formalParams -> ( formalParamsList ) .

    OPENED          reduce using rule 14 (formalParams -> ( formalParamsList ) .)
    CONTAINED       reduce using rule 14 (formalParams -> ( formalParamsList ) .)


state 101

    (16) formalParamsList -> formalParamsList , . formalParam
    (17) formalParam -> . type ID
    (18) formalParam -> . refType ID
    (40) type -> . NUMBER
    (41) type -> . LETTER
    (42) type -> . SENTENCE
    (43) refType -> . SPIDER type

    NUMBER          shift and go to state 31
    LETTER          shift and go to state 32
    SENTENCE        shift and go to state 30
    SPIDER          shift and go to state 60

    refType                        shift and go to state 59
    formalParam                    shift and go to state 109
    type                           shift and go to state 63

state 102

    (11) funcDecl -> THE ROOM ID formalParams CONTAINED A . type body
    (40) type -> . NUMBER
    (41) type -> . LETTER
    (42) type -> . SENTENCE

    NUMBER          shift and go to state 31
    LETTER          shift and go to state 32
    SENTENCE        shift and go to state 30

    type                           shift and go to state 110

state 103

    (12) procDecl -> THE LOOKING - GLASS ID formalParams . body
    (19) body -> . OPENED decls compoundStmt CLOSED
    (20) body -> . OPENED compoundStmt CLOSED
    (21) body -> . OPENED CLOSED

    OPENED          shift and go to state 112

    body                           shift and go to state 111

state 104

    (8) varDecl -> ID WAS A type TOO terminator .

    ID              reduce using rule 8 (varDecl -> ID WAS A type TOO terminator .)
    THE             reduce using rule 8 (varDecl -> ID WAS A type TOO terminator .)
    $end            reduce using rule 8 (varDecl -> ID WAS A type TOO terminator .)
    .               reduce using rule 8 (varDecl -> ID WAS A type TOO terminator .)
    ALICE           reduce using rule 8 (varDecl -> ID WAS A type TOO terminator .)
    WHAT            reduce using rule 8 (varDecl -> ID WAS A type TOO terminator .)
    EVENTUALLY      reduce using rule 8 (varDecl -> ID WAS A type TOO terminator .)
    EITHER          reduce using rule 8 (varDecl -> ID WAS A type TOO terminator .)
    OPENED          reduce using rule 8 (varDecl -> ID WAS A type TOO terminator .)
    LOGICAL_NOT     reduce using rule 8 (varDecl -> ID WAS A type TOO terminator .)
    ~               reduce using rule 8 (varDecl -> ID WAS A type TOO terminator .)
    +               reduce using rule 8 (varDecl -> ID WAS A type TOO terminator .)
    -               reduce using rule 8 (varDecl -> ID WAS A type TOO terminator .)
    STRING_LITERAL  reduce using rule 8 (varDecl -> ID WAS A type TOO terminator .)
    CHAR_LITERAL    reduce using rule 8 (varDecl -> ID WAS A type TOO terminator .)
    INT_LITERAL     reduce using rule 8 (varDecl -> ID WAS A type TOO terminator .)
    (               reduce using rule 8 (varDecl -> ID WAS A type TOO terminator .)
    PERHAPS         reduce using rule 8 (varDecl -> ID WAS A type TOO terminator .)


state 105

    (9) varDecl -> ID WAS A type OF expr . terminator
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr
    (75) terminator -> . .
    (76) terminator -> . ,
    (77) terminator -> . AND
    (78) terminator -> . BUT
    (79) terminator -> . THEN

    +               shift and go to state 48
    -               shift and go to state 50
    *               shift and go to state 49
    /               shift and go to state 51
    %               shift and go to state 45
    &               shift and go to state 47
    |               shift and go to state 57
    ^               shift and go to state 55
    LOGICAL_OR      shift and go to state 56
    LOGICAL_AND     shift and go to state 42
    GREATER_THAN    shift and go to state 41
    LESS_THAN       shift and go to state 43
    GREATER_EQUAL   shift and go to state 46
    LESS_EQUAL      shift and go to state 54
    EQUAL           shift and go to state 53
    NOT_EQUAL       shift and go to state 44
    .               shift and go to state 73
    ,               shift and go to state 69
    AND             shift and go to state 67
    BUT             shift and go to state 70
    THEN            shift and go to state 68

    terminator                     shift and go to state 113

state 106

    (71) actualParams -> ( actualParamsList ) .

    .               reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    ,               reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    AND             reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    BUT             reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    THEN            reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    BECAME          reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    ATE             reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    DRANK           reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    SPOKE           reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    SAID            reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    +               reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    -               reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    *               reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    /               reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    %               reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    &               reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    |               reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    ^               reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    LOGICAL_OR      reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    LOGICAL_AND     reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    GREATER_THAN    reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    LESS_THAN       reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    GREATER_EQUAL   reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    LESS_EQUAL      reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    EQUAL           reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    NOT_EQUAL       reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    NUMBER          reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    LETTER          reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    SENTENCE        reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    )               reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    PIECE           reduce using rule 71 (actualParams -> ( actualParamsList ) .)
    ?               reduce using rule 71 (actualParams -> ( actualParamsList ) .)


state 107

    (74) actualParamsList -> actualParamsList , . expr
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 114

state 108

    (65) expr -> ID APOSTROPHE S expr . PIECE
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    PIECE           shift and go to state 115
    +               shift and go to state 48
    -               shift and go to state 50
    *               shift and go to state 49
    /               shift and go to state 51
    %               shift and go to state 45
    &               shift and go to state 47
    |               shift and go to state 57
    ^               shift and go to state 55
    LOGICAL_OR      shift and go to state 56
    LOGICAL_AND     shift and go to state 42
    GREATER_THAN    shift and go to state 41
    LESS_THAN       shift and go to state 43
    GREATER_EQUAL   shift and go to state 46
    LESS_EQUAL      shift and go to state 54
    EQUAL           shift and go to state 53
    NOT_EQUAL       shift and go to state 44


state 109

    (16) formalParamsList -> formalParamsList , formalParam .

    )               reduce using rule 16 (formalParamsList -> formalParamsList , formalParam .)
    ,               reduce using rule 16 (formalParamsList -> formalParamsList , formalParam .)


state 110

    (11) funcDecl -> THE ROOM ID formalParams CONTAINED A type . body
    (19) body -> . OPENED decls compoundStmt CLOSED
    (20) body -> . OPENED compoundStmt CLOSED
    (21) body -> . OPENED CLOSED

    OPENED          shift and go to state 112

    body                           shift and go to state 116

state 111

    (12) procDecl -> THE LOOKING - GLASS ID formalParams body .

    ID              reduce using rule 12 (procDecl -> THE LOOKING - GLASS ID formalParams body .)
    THE             reduce using rule 12 (procDecl -> THE LOOKING - GLASS ID formalParams body .)
    $end            reduce using rule 12 (procDecl -> THE LOOKING - GLASS ID formalParams body .)
    .               reduce using rule 12 (procDecl -> THE LOOKING - GLASS ID formalParams body .)
    ALICE           reduce using rule 12 (procDecl -> THE LOOKING - GLASS ID formalParams body .)
    WHAT            reduce using rule 12 (procDecl -> THE LOOKING - GLASS ID formalParams body .)
    EVENTUALLY      reduce using rule 12 (procDecl -> THE LOOKING - GLASS ID formalParams body .)
    EITHER          reduce using rule 12 (procDecl -> THE LOOKING - GLASS ID formalParams body .)
    OPENED          reduce using rule 12 (procDecl -> THE LOOKING - GLASS ID formalParams body .)
    LOGICAL_NOT     reduce using rule 12 (procDecl -> THE LOOKING - GLASS ID formalParams body .)
    ~               reduce using rule 12 (procDecl -> THE LOOKING - GLASS ID formalParams body .)
    +               reduce using rule 12 (procDecl -> THE LOOKING - GLASS ID formalParams body .)
    -               reduce using rule 12 (procDecl -> THE LOOKING - GLASS ID formalParams body .)
    STRING_LITERAL  reduce using rule 12 (procDecl -> THE LOOKING - GLASS ID formalParams body .)
    CHAR_LITERAL    reduce using rule 12 (procDecl -> THE LOOKING - GLASS ID formalParams body .)
    INT_LITERAL     reduce using rule 12 (procDecl -> THE LOOKING - GLASS ID formalParams body .)
    (               reduce using rule 12 (procDecl -> THE LOOKING - GLASS ID formalParams body .)
    PERHAPS         reduce using rule 12 (procDecl -> THE LOOKING - GLASS ID formalParams body .)


state 112

    (19) body -> OPENED . decls compoundStmt CLOSED
    (20) body -> OPENED . compoundStmt CLOSED
    (21) body -> OPENED . CLOSED
    (2) decls -> . decls decl
    (3) decls -> . decl
    (22) compoundStmt -> . compoundStmt stmt
    (23) compoundStmt -> . stmt
    (4) decl -> . varDecl
    (5) decl -> . funcDecl
    (6) decl -> . procDecl
    (24) stmt -> . body
    (25) stmt -> . .
    (26) stmt -> . expr BECAME expr terminator
    (27) stmt -> . expr ATE terminator
    (28) stmt -> . expr DRANK terminator
    (29) stmt -> . ALICE FOUND expr .
    (30) stmt -> . expr SPOKE terminator
    (31) stmt -> . expr SAID ALICE terminator
    (32) stmt -> . WHAT WAS expr ?
    (33) stmt -> . ID actualParams terminator
    (34) stmt -> . EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES
    (35) stmt -> . EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (36) stmt -> . conditionalStmt BECAUSE ALICE WAS UNSURE WHICH
    (37) stmt -> . conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (7) varDecl -> . ID WAS A type terminator
    (8) varDecl -> . ID WAS A type TOO terminator
    (9) varDecl -> . ID WAS A type OF expr terminator
    (10) varDecl -> . ID HAD expr type terminator
    (11) funcDecl -> . THE ROOM ID formalParams CONTAINED A type body
    (12) procDecl -> . THE LOOKING - GLASS ID formalParams body
    (19) body -> . OPENED decls compoundStmt CLOSED
    (20) body -> . OPENED compoundStmt CLOSED
    (21) body -> . OPENED CLOSED
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams
    (38) conditionalStmt -> . PERHAPS ( expr ) SO compoundStmt
    (39) conditionalStmt -> . conditionalStmt OR MAYBE ( expr ) SO compoundStmt

    CLOSED          shift and go to state 129
    .               shift and go to state 119
    ALICE           shift and go to state 122
    WHAT            shift and go to state 118
    ID              shift and go to state 124
    EVENTUALLY      shift and go to state 121
    EITHER          shift and go to state 128
    THE             shift and go to state 5
    OPENED          shift and go to state 112
    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17
    PERHAPS         shift and go to state 117

    decl                           shift and go to state 1
    body                           shift and go to state 120
    procDecl                       shift and go to state 3
    conditionalStmt                shift and go to state 126
    expr                           shift and go to state 127
    funcDecl                       shift and go to state 2
    varDecl                        shift and go to state 4
    stmt                           shift and go to state 123
    decls                          shift and go to state 130
    compoundStmt                   shift and go to state 125

state 113

    (9) varDecl -> ID WAS A type OF expr terminator .

    ID              reduce using rule 9 (varDecl -> ID WAS A type OF expr terminator .)
    THE             reduce using rule 9 (varDecl -> ID WAS A type OF expr terminator .)
    $end            reduce using rule 9 (varDecl -> ID WAS A type OF expr terminator .)
    .               reduce using rule 9 (varDecl -> ID WAS A type OF expr terminator .)
    ALICE           reduce using rule 9 (varDecl -> ID WAS A type OF expr terminator .)
    WHAT            reduce using rule 9 (varDecl -> ID WAS A type OF expr terminator .)
    EVENTUALLY      reduce using rule 9 (varDecl -> ID WAS A type OF expr terminator .)
    EITHER          reduce using rule 9 (varDecl -> ID WAS A type OF expr terminator .)
    OPENED          reduce using rule 9 (varDecl -> ID WAS A type OF expr terminator .)
    LOGICAL_NOT     reduce using rule 9 (varDecl -> ID WAS A type OF expr terminator .)
    ~               reduce using rule 9 (varDecl -> ID WAS A type OF expr terminator .)
    +               reduce using rule 9 (varDecl -> ID WAS A type OF expr terminator .)
    -               reduce using rule 9 (varDecl -> ID WAS A type OF expr terminator .)
    STRING_LITERAL  reduce using rule 9 (varDecl -> ID WAS A type OF expr terminator .)
    CHAR_LITERAL    reduce using rule 9 (varDecl -> ID WAS A type OF expr terminator .)
    INT_LITERAL     reduce using rule 9 (varDecl -> ID WAS A type OF expr terminator .)
    (               reduce using rule 9 (varDecl -> ID WAS A type OF expr terminator .)
    PERHAPS         reduce using rule 9 (varDecl -> ID WAS A type OF expr terminator .)


state 114

    (74) actualParamsList -> actualParamsList , expr .
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    )               reduce using rule 74 (actualParamsList -> actualParamsList , expr .)
    ,               reduce using rule 74 (actualParamsList -> actualParamsList , expr .)
    +               shift and go to state 48
    -               shift and go to state 50
    *               shift and go to state 49
    /               shift and go to state 51
    %               shift and go to state 45
    &               shift and go to state 47
    |               shift and go to state 57
    ^               shift and go to state 55
    LOGICAL_OR      shift and go to state 56
    LOGICAL_AND     shift and go to state 42
    GREATER_THAN    shift and go to state 41
    LESS_THAN       shift and go to state 43
    GREATER_EQUAL   shift and go to state 46
    LESS_EQUAL      shift and go to state 54
    EQUAL           shift and go to state 53
    NOT_EQUAL       shift and go to state 44


state 115

    (65) expr -> ID APOSTROPHE S expr PIECE .

    +               reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    -               reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    *               reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    /               reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    %               reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    &               reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    |               reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    ^               reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    LOGICAL_OR      reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    LOGICAL_AND     reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    GREATER_THAN    reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    LESS_THAN       reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    GREATER_EQUAL   reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    LESS_EQUAL      reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    EQUAL           reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    NOT_EQUAL       reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    NUMBER          reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    LETTER          reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    SENTENCE        reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    )               reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    ,               reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    .               reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    AND             reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    BUT             reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    THEN            reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    PIECE           reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    BECAME          reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    ATE             reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    DRANK           reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    SPOKE           reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    SAID            reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)
    ?               reduce using rule 65 (expr -> ID APOSTROPHE S expr PIECE .)


state 116

    (11) funcDecl -> THE ROOM ID formalParams CONTAINED A type body .

    ID              reduce using rule 11 (funcDecl -> THE ROOM ID formalParams CONTAINED A type body .)
    THE             reduce using rule 11 (funcDecl -> THE ROOM ID formalParams CONTAINED A type body .)
    $end            reduce using rule 11 (funcDecl -> THE ROOM ID formalParams CONTAINED A type body .)
    .               reduce using rule 11 (funcDecl -> THE ROOM ID formalParams CONTAINED A type body .)
    ALICE           reduce using rule 11 (funcDecl -> THE ROOM ID formalParams CONTAINED A type body .)
    WHAT            reduce using rule 11 (funcDecl -> THE ROOM ID formalParams CONTAINED A type body .)
    EVENTUALLY      reduce using rule 11 (funcDecl -> THE ROOM ID formalParams CONTAINED A type body .)
    EITHER          reduce using rule 11 (funcDecl -> THE ROOM ID formalParams CONTAINED A type body .)
    OPENED          reduce using rule 11 (funcDecl -> THE ROOM ID formalParams CONTAINED A type body .)
    LOGICAL_NOT     reduce using rule 11 (funcDecl -> THE ROOM ID formalParams CONTAINED A type body .)
    ~               reduce using rule 11 (funcDecl -> THE ROOM ID formalParams CONTAINED A type body .)
    +               reduce using rule 11 (funcDecl -> THE ROOM ID formalParams CONTAINED A type body .)
    -               reduce using rule 11 (funcDecl -> THE ROOM ID formalParams CONTAINED A type body .)
    STRING_LITERAL  reduce using rule 11 (funcDecl -> THE ROOM ID formalParams CONTAINED A type body .)
    CHAR_LITERAL    reduce using rule 11 (funcDecl -> THE ROOM ID formalParams CONTAINED A type body .)
    INT_LITERAL     reduce using rule 11 (funcDecl -> THE ROOM ID formalParams CONTAINED A type body .)
    (               reduce using rule 11 (funcDecl -> THE ROOM ID formalParams CONTAINED A type body .)
    PERHAPS         reduce using rule 11 (funcDecl -> THE ROOM ID formalParams CONTAINED A type body .)


state 117

    (38) conditionalStmt -> PERHAPS . ( expr ) SO compoundStmt

    (               shift and go to state 131


state 118

    (32) stmt -> WHAT . WAS expr ?

    WAS             shift and go to state 132


state 119

    (25) stmt -> . .

    OR              reduce using rule 25 (stmt -> . .)
    .               reduce using rule 25 (stmt -> . .)
    ALICE           reduce using rule 25 (stmt -> . .)
    WHAT            reduce using rule 25 (stmt -> . .)
    ID              reduce using rule 25 (stmt -> . .)
    EVENTUALLY      reduce using rule 25 (stmt -> . .)
    EITHER          reduce using rule 25 (stmt -> . .)
    OPENED          reduce using rule 25 (stmt -> . .)
    LOGICAL_NOT     reduce using rule 25 (stmt -> . .)
    ~               reduce using rule 25 (stmt -> . .)
    +               reduce using rule 25 (stmt -> . .)
    -               reduce using rule 25 (stmt -> . .)
    STRING_LITERAL  reduce using rule 25 (stmt -> . .)
    CHAR_LITERAL    reduce using rule 25 (stmt -> . .)
    INT_LITERAL     reduce using rule 25 (stmt -> . .)
    (               reduce using rule 25 (stmt -> . .)
    PERHAPS         reduce using rule 25 (stmt -> . .)
    ENOUGH          reduce using rule 25 (stmt -> . .)
    CLOSED          reduce using rule 25 (stmt -> . .)
    BECAUSE         reduce using rule 25 (stmt -> . .)


state 120

    (24) stmt -> body .

    OR              reduce using rule 24 (stmt -> body .)
    .               reduce using rule 24 (stmt -> body .)
    ALICE           reduce using rule 24 (stmt -> body .)
    WHAT            reduce using rule 24 (stmt -> body .)
    ID              reduce using rule 24 (stmt -> body .)
    EVENTUALLY      reduce using rule 24 (stmt -> body .)
    EITHER          reduce using rule 24 (stmt -> body .)
    OPENED          reduce using rule 24 (stmt -> body .)
    LOGICAL_NOT     reduce using rule 24 (stmt -> body .)
    ~               reduce using rule 24 (stmt -> body .)
    +               reduce using rule 24 (stmt -> body .)
    -               reduce using rule 24 (stmt -> body .)
    STRING_LITERAL  reduce using rule 24 (stmt -> body .)
    CHAR_LITERAL    reduce using rule 24 (stmt -> body .)
    INT_LITERAL     reduce using rule 24 (stmt -> body .)
    (               reduce using rule 24 (stmt -> body .)
    PERHAPS         reduce using rule 24 (stmt -> body .)
    ENOUGH          reduce using rule 24 (stmt -> body .)
    CLOSED          reduce using rule 24 (stmt -> body .)
    BECAUSE         reduce using rule 24 (stmt -> body .)


state 121

    (34) stmt -> EVENTUALLY . ( expr ) BECAUSE compoundStmt ENOUGH TIMES

    (               shift and go to state 133


state 122

    (29) stmt -> ALICE . FOUND expr .

    FOUND           shift and go to state 134


state 123

    (23) compoundStmt -> stmt .

    .               reduce using rule 23 (compoundStmt -> stmt .)
    ALICE           reduce using rule 23 (compoundStmt -> stmt .)
    WHAT            reduce using rule 23 (compoundStmt -> stmt .)
    ID              reduce using rule 23 (compoundStmt -> stmt .)
    EVENTUALLY      reduce using rule 23 (compoundStmt -> stmt .)
    EITHER          reduce using rule 23 (compoundStmt -> stmt .)
    OPENED          reduce using rule 23 (compoundStmt -> stmt .)
    LOGICAL_NOT     reduce using rule 23 (compoundStmt -> stmt .)
    ~               reduce using rule 23 (compoundStmt -> stmt .)
    +               reduce using rule 23 (compoundStmt -> stmt .)
    -               reduce using rule 23 (compoundStmt -> stmt .)
    STRING_LITERAL  reduce using rule 23 (compoundStmt -> stmt .)
    CHAR_LITERAL    reduce using rule 23 (compoundStmt -> stmt .)
    INT_LITERAL     reduce using rule 23 (compoundStmt -> stmt .)
    (               reduce using rule 23 (compoundStmt -> stmt .)
    PERHAPS         reduce using rule 23 (compoundStmt -> stmt .)
    BECAUSE         reduce using rule 23 (compoundStmt -> stmt .)
    OR              reduce using rule 23 (compoundStmt -> stmt .)
    ENOUGH          reduce using rule 23 (compoundStmt -> stmt .)
    CLOSED          reduce using rule 23 (compoundStmt -> stmt .)


state 124

    (33) stmt -> ID . actualParams terminator
    (7) varDecl -> ID . WAS A type terminator
    (8) varDecl -> ID . WAS A type TOO terminator
    (9) varDecl -> ID . WAS A type OF expr terminator
    (10) varDecl -> ID . HAD expr type terminator
    (64) expr -> ID .
    (65) expr -> ID . APOSTROPHE S expr PIECE
    (70) expr -> ID . actualParams
    (71) actualParams -> . ( actualParamsList )
    (72) actualParams -> . ( )

    WAS             shift and go to state 11
    HAD             shift and go to state 12
    BECAME          reduce using rule 64 (expr -> ID .)
    ATE             reduce using rule 64 (expr -> ID .)
    DRANK           reduce using rule 64 (expr -> ID .)
    SPOKE           reduce using rule 64 (expr -> ID .)
    SAID            reduce using rule 64 (expr -> ID .)
    +               reduce using rule 64 (expr -> ID .)
    -               reduce using rule 64 (expr -> ID .)
    *               reduce using rule 64 (expr -> ID .)
    /               reduce using rule 64 (expr -> ID .)
    %               reduce using rule 64 (expr -> ID .)
    &               reduce using rule 64 (expr -> ID .)
    |               reduce using rule 64 (expr -> ID .)
    ^               reduce using rule 64 (expr -> ID .)
    LOGICAL_OR      reduce using rule 64 (expr -> ID .)
    LOGICAL_AND     reduce using rule 64 (expr -> ID .)
    GREATER_THAN    reduce using rule 64 (expr -> ID .)
    LESS_THAN       reduce using rule 64 (expr -> ID .)
    GREATER_EQUAL   reduce using rule 64 (expr -> ID .)
    LESS_EQUAL      reduce using rule 64 (expr -> ID .)
    EQUAL           reduce using rule 64 (expr -> ID .)
    NOT_EQUAL       reduce using rule 64 (expr -> ID .)
    APOSTROPHE      shift and go to state 39
    (               shift and go to state 38

    actualParams                   shift and go to state 135

state 125

    (20) body -> OPENED compoundStmt . CLOSED
    (22) compoundStmt -> compoundStmt . stmt
    (24) stmt -> . body
    (25) stmt -> . .
    (26) stmt -> . expr BECAME expr terminator
    (27) stmt -> . expr ATE terminator
    (28) stmt -> . expr DRANK terminator
    (29) stmt -> . ALICE FOUND expr .
    (30) stmt -> . expr SPOKE terminator
    (31) stmt -> . expr SAID ALICE terminator
    (32) stmt -> . WHAT WAS expr ?
    (33) stmt -> . ID actualParams terminator
    (34) stmt -> . EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES
    (35) stmt -> . EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (36) stmt -> . conditionalStmt BECAUSE ALICE WAS UNSURE WHICH
    (37) stmt -> . conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (19) body -> . OPENED decls compoundStmt CLOSED
    (20) body -> . OPENED compoundStmt CLOSED
    (21) body -> . OPENED CLOSED
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams
    (38) conditionalStmt -> . PERHAPS ( expr ) SO compoundStmt
    (39) conditionalStmt -> . conditionalStmt OR MAYBE ( expr ) SO compoundStmt

    CLOSED          shift and go to state 138
    .               shift and go to state 119
    ALICE           shift and go to state 122
    WHAT            shift and go to state 118
    ID              shift and go to state 137
    EVENTUALLY      shift and go to state 121
    EITHER          shift and go to state 128
    OPENED          shift and go to state 112
    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17
    PERHAPS         shift and go to state 117

    body                           shift and go to state 120
    conditionalStmt                shift and go to state 126
    expr                           shift and go to state 127
    stmt                           shift and go to state 136

state 126

    (36) stmt -> conditionalStmt . BECAUSE ALICE WAS UNSURE WHICH
    (37) stmt -> conditionalStmt . OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (39) conditionalStmt -> conditionalStmt . OR MAYBE ( expr ) SO compoundStmt

    BECAUSE         shift and go to state 139
    OR              shift and go to state 140


state 127

    (26) stmt -> expr . BECAME expr terminator
    (27) stmt -> expr . ATE terminator
    (28) stmt -> expr . DRANK terminator
    (30) stmt -> expr . SPOKE terminator
    (31) stmt -> expr . SAID ALICE terminator
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    BECAME          shift and go to state 145
    ATE             shift and go to state 141
    DRANK           shift and go to state 143
    SPOKE           shift and go to state 142
    SAID            shift and go to state 144
    +               shift and go to state 48
    -               shift and go to state 50
    *               shift and go to state 49
    /               shift and go to state 51
    %               shift and go to state 45
    &               shift and go to state 47
    |               shift and go to state 57
    ^               shift and go to state 55
    LOGICAL_OR      shift and go to state 56
    LOGICAL_AND     shift and go to state 42
    GREATER_THAN    shift and go to state 41
    LESS_THAN       shift and go to state 43
    GREATER_EQUAL   shift and go to state 46
    LESS_EQUAL      shift and go to state 54
    EQUAL           shift and go to state 53
    NOT_EQUAL       shift and go to state 44


state 128

    (35) stmt -> EITHER . ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH

    (               shift and go to state 146


state 129

    (21) body -> OPENED CLOSED .

    ID              reduce using rule 21 (body -> OPENED CLOSED .)
    THE             reduce using rule 21 (body -> OPENED CLOSED .)
    $end            reduce using rule 21 (body -> OPENED CLOSED .)
    .               reduce using rule 21 (body -> OPENED CLOSED .)
    ALICE           reduce using rule 21 (body -> OPENED CLOSED .)
    WHAT            reduce using rule 21 (body -> OPENED CLOSED .)
    EVENTUALLY      reduce using rule 21 (body -> OPENED CLOSED .)
    EITHER          reduce using rule 21 (body -> OPENED CLOSED .)
    OPENED          reduce using rule 21 (body -> OPENED CLOSED .)
    LOGICAL_NOT     reduce using rule 21 (body -> OPENED CLOSED .)
    ~               reduce using rule 21 (body -> OPENED CLOSED .)
    +               reduce using rule 21 (body -> OPENED CLOSED .)
    -               reduce using rule 21 (body -> OPENED CLOSED .)
    STRING_LITERAL  reduce using rule 21 (body -> OPENED CLOSED .)
    CHAR_LITERAL    reduce using rule 21 (body -> OPENED CLOSED .)
    INT_LITERAL     reduce using rule 21 (body -> OPENED CLOSED .)
    (               reduce using rule 21 (body -> OPENED CLOSED .)
    PERHAPS         reduce using rule 21 (body -> OPENED CLOSED .)
    BECAUSE         reduce using rule 21 (body -> OPENED CLOSED .)
    OR              reduce using rule 21 (body -> OPENED CLOSED .)
    CLOSED          reduce using rule 21 (body -> OPENED CLOSED .)
    ENOUGH          reduce using rule 21 (body -> OPENED CLOSED .)


state 130

    (19) body -> OPENED decls . compoundStmt CLOSED
    (2) decls -> decls . decl
    (22) compoundStmt -> . compoundStmt stmt
    (23) compoundStmt -> . stmt
    (4) decl -> . varDecl
    (5) decl -> . funcDecl
    (6) decl -> . procDecl
    (24) stmt -> . body
    (25) stmt -> . .
    (26) stmt -> . expr BECAME expr terminator
    (27) stmt -> . expr ATE terminator
    (28) stmt -> . expr DRANK terminator
    (29) stmt -> . ALICE FOUND expr .
    (30) stmt -> . expr SPOKE terminator
    (31) stmt -> . expr SAID ALICE terminator
    (32) stmt -> . WHAT WAS expr ?
    (33) stmt -> . ID actualParams terminator
    (34) stmt -> . EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES
    (35) stmt -> . EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (36) stmt -> . conditionalStmt BECAUSE ALICE WAS UNSURE WHICH
    (37) stmt -> . conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (7) varDecl -> . ID WAS A type terminator
    (8) varDecl -> . ID WAS A type TOO terminator
    (9) varDecl -> . ID WAS A type OF expr terminator
    (10) varDecl -> . ID HAD expr type terminator
    (11) funcDecl -> . THE ROOM ID formalParams CONTAINED A type body
    (12) procDecl -> . THE LOOKING - GLASS ID formalParams body
    (19) body -> . OPENED decls compoundStmt CLOSED
    (20) body -> . OPENED compoundStmt CLOSED
    (21) body -> . OPENED CLOSED
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams
    (38) conditionalStmt -> . PERHAPS ( expr ) SO compoundStmt
    (39) conditionalStmt -> . conditionalStmt OR MAYBE ( expr ) SO compoundStmt

    .               shift and go to state 119
    ALICE           shift and go to state 122
    WHAT            shift and go to state 118
    ID              shift and go to state 124
    EVENTUALLY      shift and go to state 121
    EITHER          shift and go to state 128
    THE             shift and go to state 5
    OPENED          shift and go to state 112
    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17
    PERHAPS         shift and go to state 117

    decl                           shift and go to state 13
    body                           shift and go to state 120
    procDecl                       shift and go to state 3
    conditionalStmt                shift and go to state 126
    expr                           shift and go to state 127
    funcDecl                       shift and go to state 2
    varDecl                        shift and go to state 4
    stmt                           shift and go to state 123
    compoundStmt                   shift and go to state 147

state 131

    (38) conditionalStmt -> PERHAPS ( . expr ) SO compoundStmt
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 148

state 132

    (32) stmt -> WHAT WAS . expr ?
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 149

state 133

    (34) stmt -> EVENTUALLY ( . expr ) BECAUSE compoundStmt ENOUGH TIMES
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 150

state 134

    (29) stmt -> ALICE FOUND . expr .
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 151

state 135

    (33) stmt -> ID actualParams . terminator
    (70) expr -> ID actualParams .
    (75) terminator -> . .
    (76) terminator -> . ,
    (77) terminator -> . AND
    (78) terminator -> . BUT
    (79) terminator -> . THEN

    BECAME          reduce using rule 70 (expr -> ID actualParams .)
    ATE             reduce using rule 70 (expr -> ID actualParams .)
    DRANK           reduce using rule 70 (expr -> ID actualParams .)
    SPOKE           reduce using rule 70 (expr -> ID actualParams .)
    SAID            reduce using rule 70 (expr -> ID actualParams .)
    +               reduce using rule 70 (expr -> ID actualParams .)
    -               reduce using rule 70 (expr -> ID actualParams .)
    *               reduce using rule 70 (expr -> ID actualParams .)
    /               reduce using rule 70 (expr -> ID actualParams .)
    %               reduce using rule 70 (expr -> ID actualParams .)
    &               reduce using rule 70 (expr -> ID actualParams .)
    |               reduce using rule 70 (expr -> ID actualParams .)
    ^               reduce using rule 70 (expr -> ID actualParams .)
    LOGICAL_OR      reduce using rule 70 (expr -> ID actualParams .)
    LOGICAL_AND     reduce using rule 70 (expr -> ID actualParams .)
    GREATER_THAN    reduce using rule 70 (expr -> ID actualParams .)
    LESS_THAN       reduce using rule 70 (expr -> ID actualParams .)
    GREATER_EQUAL   reduce using rule 70 (expr -> ID actualParams .)
    LESS_EQUAL      reduce using rule 70 (expr -> ID actualParams .)
    EQUAL           reduce using rule 70 (expr -> ID actualParams .)
    NOT_EQUAL       reduce using rule 70 (expr -> ID actualParams .)
    .               shift and go to state 73
    ,               shift and go to state 69
    AND             shift and go to state 67
    BUT             shift and go to state 70
    THEN            shift and go to state 68

    terminator                     shift and go to state 152

state 136

    (22) compoundStmt -> compoundStmt stmt .

    .               reduce using rule 22 (compoundStmt -> compoundStmt stmt .)
    ALICE           reduce using rule 22 (compoundStmt -> compoundStmt stmt .)
    WHAT            reduce using rule 22 (compoundStmt -> compoundStmt stmt .)
    ID              reduce using rule 22 (compoundStmt -> compoundStmt stmt .)
    EVENTUALLY      reduce using rule 22 (compoundStmt -> compoundStmt stmt .)
    EITHER          reduce using rule 22 (compoundStmt -> compoundStmt stmt .)
    OPENED          reduce using rule 22 (compoundStmt -> compoundStmt stmt .)
    LOGICAL_NOT     reduce using rule 22 (compoundStmt -> compoundStmt stmt .)
    ~               reduce using rule 22 (compoundStmt -> compoundStmt stmt .)
    +               reduce using rule 22 (compoundStmt -> compoundStmt stmt .)
    -               reduce using rule 22 (compoundStmt -> compoundStmt stmt .)
    STRING_LITERAL  reduce using rule 22 (compoundStmt -> compoundStmt stmt .)
    CHAR_LITERAL    reduce using rule 22 (compoundStmt -> compoundStmt stmt .)
    INT_LITERAL     reduce using rule 22 (compoundStmt -> compoundStmt stmt .)
    (               reduce using rule 22 (compoundStmt -> compoundStmt stmt .)
    PERHAPS         reduce using rule 22 (compoundStmt -> compoundStmt stmt .)
    BECAUSE         reduce using rule 22 (compoundStmt -> compoundStmt stmt .)
    OR              reduce using rule 22 (compoundStmt -> compoundStmt stmt .)
    ENOUGH          reduce using rule 22 (compoundStmt -> compoundStmt stmt .)
    CLOSED          reduce using rule 22 (compoundStmt -> compoundStmt stmt .)


state 137

    (33) stmt -> ID . actualParams terminator
    (64) expr -> ID .
    (65) expr -> ID . APOSTROPHE S expr PIECE
    (70) expr -> ID . actualParams
    (71) actualParams -> . ( actualParamsList )
    (72) actualParams -> . ( )

    BECAME          reduce using rule 64 (expr -> ID .)
    ATE             reduce using rule 64 (expr -> ID .)
    DRANK           reduce using rule 64 (expr -> ID .)
    SPOKE           reduce using rule 64 (expr -> ID .)
    SAID            reduce using rule 64 (expr -> ID .)
    +               reduce using rule 64 (expr -> ID .)
    -               reduce using rule 64 (expr -> ID .)
    *               reduce using rule 64 (expr -> ID .)
    /               reduce using rule 64 (expr -> ID .)
    %               reduce using rule 64 (expr -> ID .)
    &               reduce using rule 64 (expr -> ID .)
    |               reduce using rule 64 (expr -> ID .)
    ^               reduce using rule 64 (expr -> ID .)
    LOGICAL_OR      reduce using rule 64 (expr -> ID .)
    LOGICAL_AND     reduce using rule 64 (expr -> ID .)
    GREATER_THAN    reduce using rule 64 (expr -> ID .)
    LESS_THAN       reduce using rule 64 (expr -> ID .)
    GREATER_EQUAL   reduce using rule 64 (expr -> ID .)
    LESS_EQUAL      reduce using rule 64 (expr -> ID .)
    EQUAL           reduce using rule 64 (expr -> ID .)
    NOT_EQUAL       reduce using rule 64 (expr -> ID .)
    APOSTROPHE      shift and go to state 39
    (               shift and go to state 38

    actualParams                   shift and go to state 135

state 138

    (20) body -> OPENED compoundStmt CLOSED .

    ID              reduce using rule 20 (body -> OPENED compoundStmt CLOSED .)
    THE             reduce using rule 20 (body -> OPENED compoundStmt CLOSED .)
    $end            reduce using rule 20 (body -> OPENED compoundStmt CLOSED .)
    .               reduce using rule 20 (body -> OPENED compoundStmt CLOSED .)
    ALICE           reduce using rule 20 (body -> OPENED compoundStmt CLOSED .)
    WHAT            reduce using rule 20 (body -> OPENED compoundStmt CLOSED .)
    EVENTUALLY      reduce using rule 20 (body -> OPENED compoundStmt CLOSED .)
    EITHER          reduce using rule 20 (body -> OPENED compoundStmt CLOSED .)
    OPENED          reduce using rule 20 (body -> OPENED compoundStmt CLOSED .)
    LOGICAL_NOT     reduce using rule 20 (body -> OPENED compoundStmt CLOSED .)
    ~               reduce using rule 20 (body -> OPENED compoundStmt CLOSED .)
    +               reduce using rule 20 (body -> OPENED compoundStmt CLOSED .)
    -               reduce using rule 20 (body -> OPENED compoundStmt CLOSED .)
    STRING_LITERAL  reduce using rule 20 (body -> OPENED compoundStmt CLOSED .)
    CHAR_LITERAL    reduce using rule 20 (body -> OPENED compoundStmt CLOSED .)
    INT_LITERAL     reduce using rule 20 (body -> OPENED compoundStmt CLOSED .)
    (               reduce using rule 20 (body -> OPENED compoundStmt CLOSED .)
    PERHAPS         reduce using rule 20 (body -> OPENED compoundStmt CLOSED .)
    BECAUSE         reduce using rule 20 (body -> OPENED compoundStmt CLOSED .)
    OR              reduce using rule 20 (body -> OPENED compoundStmt CLOSED .)
    CLOSED          reduce using rule 20 (body -> OPENED compoundStmt CLOSED .)
    ENOUGH          reduce using rule 20 (body -> OPENED compoundStmt CLOSED .)


state 139

    (36) stmt -> conditionalStmt BECAUSE . ALICE WAS UNSURE WHICH

    ALICE           shift and go to state 153


state 140

    (37) stmt -> conditionalStmt OR . compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (39) conditionalStmt -> conditionalStmt OR . MAYBE ( expr ) SO compoundStmt
    (22) compoundStmt -> . compoundStmt stmt
    (23) compoundStmt -> . stmt
    (24) stmt -> . body
    (25) stmt -> . .
    (26) stmt -> . expr BECAME expr terminator
    (27) stmt -> . expr ATE terminator
    (28) stmt -> . expr DRANK terminator
    (29) stmt -> . ALICE FOUND expr .
    (30) stmt -> . expr SPOKE terminator
    (31) stmt -> . expr SAID ALICE terminator
    (32) stmt -> . WHAT WAS expr ?
    (33) stmt -> . ID actualParams terminator
    (34) stmt -> . EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES
    (35) stmt -> . EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (36) stmt -> . conditionalStmt BECAUSE ALICE WAS UNSURE WHICH
    (37) stmt -> . conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (19) body -> . OPENED decls compoundStmt CLOSED
    (20) body -> . OPENED compoundStmt CLOSED
    (21) body -> . OPENED CLOSED
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams
    (38) conditionalStmt -> . PERHAPS ( expr ) SO compoundStmt
    (39) conditionalStmt -> . conditionalStmt OR MAYBE ( expr ) SO compoundStmt

    MAYBE           shift and go to state 154
    .               shift and go to state 119
    ALICE           shift and go to state 122
    WHAT            shift and go to state 118
    ID              shift and go to state 137
    EVENTUALLY      shift and go to state 121
    EITHER          shift and go to state 128
    OPENED          shift and go to state 112
    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17
    PERHAPS         shift and go to state 117

    body                           shift and go to state 120
    conditionalStmt                shift and go to state 126
    expr                           shift and go to state 127
    stmt                           shift and go to state 123
    compoundStmt                   shift and go to state 155

state 141

    (27) stmt -> expr ATE . terminator
    (75) terminator -> . .
    (76) terminator -> . ,
    (77) terminator -> . AND
    (78) terminator -> . BUT
    (79) terminator -> . THEN

    .               shift and go to state 73
    ,               shift and go to state 69
    AND             shift and go to state 67
    BUT             shift and go to state 70
    THEN            shift and go to state 68

    terminator                     shift and go to state 156

state 142

    (30) stmt -> expr SPOKE . terminator
    (75) terminator -> . .
    (76) terminator -> . ,
    (77) terminator -> . AND
    (78) terminator -> . BUT
    (79) terminator -> . THEN

    .               shift and go to state 73
    ,               shift and go to state 69
    AND             shift and go to state 67
    BUT             shift and go to state 70
    THEN            shift and go to state 68

    terminator                     shift and go to state 157

state 143

    (28) stmt -> expr DRANK . terminator
    (75) terminator -> . .
    (76) terminator -> . ,
    (77) terminator -> . AND
    (78) terminator -> . BUT
    (79) terminator -> . THEN

    .               shift and go to state 73
    ,               shift and go to state 69
    AND             shift and go to state 67
    BUT             shift and go to state 70
    THEN            shift and go to state 68

    terminator                     shift and go to state 158

state 144

    (31) stmt -> expr SAID . ALICE terminator

    ALICE           shift and go to state 159


state 145

    (26) stmt -> expr BECAME . expr terminator
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 160

state 146

    (35) stmt -> EITHER ( . expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 161

state 147

    (19) body -> OPENED decls compoundStmt . CLOSED
    (22) compoundStmt -> compoundStmt . stmt
    (24) stmt -> . body
    (25) stmt -> . .
    (26) stmt -> . expr BECAME expr terminator
    (27) stmt -> . expr ATE terminator
    (28) stmt -> . expr DRANK terminator
    (29) stmt -> . ALICE FOUND expr .
    (30) stmt -> . expr SPOKE terminator
    (31) stmt -> . expr SAID ALICE terminator
    (32) stmt -> . WHAT WAS expr ?
    (33) stmt -> . ID actualParams terminator
    (34) stmt -> . EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES
    (35) stmt -> . EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (36) stmt -> . conditionalStmt BECAUSE ALICE WAS UNSURE WHICH
    (37) stmt -> . conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (19) body -> . OPENED decls compoundStmt CLOSED
    (20) body -> . OPENED compoundStmt CLOSED
    (21) body -> . OPENED CLOSED
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams
    (38) conditionalStmt -> . PERHAPS ( expr ) SO compoundStmt
    (39) conditionalStmt -> . conditionalStmt OR MAYBE ( expr ) SO compoundStmt

    CLOSED          shift and go to state 162
    .               shift and go to state 119
    ALICE           shift and go to state 122
    WHAT            shift and go to state 118
    ID              shift and go to state 137
    EVENTUALLY      shift and go to state 121
    EITHER          shift and go to state 128
    OPENED          shift and go to state 112
    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17
    PERHAPS         shift and go to state 117

    body                           shift and go to state 120
    conditionalStmt                shift and go to state 126
    expr                           shift and go to state 127
    stmt                           shift and go to state 136

state 148

    (38) conditionalStmt -> PERHAPS ( expr . ) SO compoundStmt
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    )               shift and go to state 163
    +               shift and go to state 48
    -               shift and go to state 50
    *               shift and go to state 49
    /               shift and go to state 51
    %               shift and go to state 45
    &               shift and go to state 47
    |               shift and go to state 57
    ^               shift and go to state 55
    LOGICAL_OR      shift and go to state 56
    LOGICAL_AND     shift and go to state 42
    GREATER_THAN    shift and go to state 41
    LESS_THAN       shift and go to state 43
    GREATER_EQUAL   shift and go to state 46
    LESS_EQUAL      shift and go to state 54
    EQUAL           shift and go to state 53
    NOT_EQUAL       shift and go to state 44


state 149

    (32) stmt -> WHAT WAS expr . ?
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    ?               shift and go to state 164
    +               shift and go to state 48
    -               shift and go to state 50
    *               shift and go to state 49
    /               shift and go to state 51
    %               shift and go to state 45
    &               shift and go to state 47
    |               shift and go to state 57
    ^               shift and go to state 55
    LOGICAL_OR      shift and go to state 56
    LOGICAL_AND     shift and go to state 42
    GREATER_THAN    shift and go to state 41
    LESS_THAN       shift and go to state 43
    GREATER_EQUAL   shift and go to state 46
    LESS_EQUAL      shift and go to state 54
    EQUAL           shift and go to state 53
    NOT_EQUAL       shift and go to state 44


state 150

    (34) stmt -> EVENTUALLY ( expr . ) BECAUSE compoundStmt ENOUGH TIMES
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    )               shift and go to state 165
    +               shift and go to state 48
    -               shift and go to state 50
    *               shift and go to state 49
    /               shift and go to state 51
    %               shift and go to state 45
    &               shift and go to state 47
    |               shift and go to state 57
    ^               shift and go to state 55
    LOGICAL_OR      shift and go to state 56
    LOGICAL_AND     shift and go to state 42
    GREATER_THAN    shift and go to state 41
    LESS_THAN       shift and go to state 43
    GREATER_EQUAL   shift and go to state 46
    LESS_EQUAL      shift and go to state 54
    EQUAL           shift and go to state 53
    NOT_EQUAL       shift and go to state 44


state 151

    (29) stmt -> ALICE FOUND expr . .
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    .               shift and go to state 166
    +               shift and go to state 48
    -               shift and go to state 50
    *               shift and go to state 49
    /               shift and go to state 51
    %               shift and go to state 45
    &               shift and go to state 47
    |               shift and go to state 57
    ^               shift and go to state 55
    LOGICAL_OR      shift and go to state 56
    LOGICAL_AND     shift and go to state 42
    GREATER_THAN    shift and go to state 41
    LESS_THAN       shift and go to state 43
    GREATER_EQUAL   shift and go to state 46
    LESS_EQUAL      shift and go to state 54
    EQUAL           shift and go to state 53
    NOT_EQUAL       shift and go to state 44


state 152

    (33) stmt -> ID actualParams terminator .

    OR              reduce using rule 33 (stmt -> ID actualParams terminator .)
    .               reduce using rule 33 (stmt -> ID actualParams terminator .)
    ALICE           reduce using rule 33 (stmt -> ID actualParams terminator .)
    WHAT            reduce using rule 33 (stmt -> ID actualParams terminator .)
    ID              reduce using rule 33 (stmt -> ID actualParams terminator .)
    EVENTUALLY      reduce using rule 33 (stmt -> ID actualParams terminator .)
    EITHER          reduce using rule 33 (stmt -> ID actualParams terminator .)
    OPENED          reduce using rule 33 (stmt -> ID actualParams terminator .)
    LOGICAL_NOT     reduce using rule 33 (stmt -> ID actualParams terminator .)
    ~               reduce using rule 33 (stmt -> ID actualParams terminator .)
    +               reduce using rule 33 (stmt -> ID actualParams terminator .)
    -               reduce using rule 33 (stmt -> ID actualParams terminator .)
    STRING_LITERAL  reduce using rule 33 (stmt -> ID actualParams terminator .)
    CHAR_LITERAL    reduce using rule 33 (stmt -> ID actualParams terminator .)
    INT_LITERAL     reduce using rule 33 (stmt -> ID actualParams terminator .)
    (               reduce using rule 33 (stmt -> ID actualParams terminator .)
    PERHAPS         reduce using rule 33 (stmt -> ID actualParams terminator .)
    ENOUGH          reduce using rule 33 (stmt -> ID actualParams terminator .)
    CLOSED          reduce using rule 33 (stmt -> ID actualParams terminator .)
    BECAUSE         reduce using rule 33 (stmt -> ID actualParams terminator .)


state 153

    (36) stmt -> conditionalStmt BECAUSE ALICE . WAS UNSURE WHICH

    WAS             shift and go to state 167


state 154

    (39) conditionalStmt -> conditionalStmt OR MAYBE . ( expr ) SO compoundStmt

    (               shift and go to state 168


state 155

    (37) stmt -> conditionalStmt OR compoundStmt . BECAUSE ALICE WAS UNSURE WHICH
    (22) compoundStmt -> compoundStmt . stmt
    (24) stmt -> . body
    (25) stmt -> . .
    (26) stmt -> . expr BECAME expr terminator
    (27) stmt -> . expr ATE terminator
    (28) stmt -> . expr DRANK terminator
    (29) stmt -> . ALICE FOUND expr .
    (30) stmt -> . expr SPOKE terminator
    (31) stmt -> . expr SAID ALICE terminator
    (32) stmt -> . WHAT WAS expr ?
    (33) stmt -> . ID actualParams terminator
    (34) stmt -> . EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES
    (35) stmt -> . EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (36) stmt -> . conditionalStmt BECAUSE ALICE WAS UNSURE WHICH
    (37) stmt -> . conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (19) body -> . OPENED decls compoundStmt CLOSED
    (20) body -> . OPENED compoundStmt CLOSED
    (21) body -> . OPENED CLOSED
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams
    (38) conditionalStmt -> . PERHAPS ( expr ) SO compoundStmt
    (39) conditionalStmt -> . conditionalStmt OR MAYBE ( expr ) SO compoundStmt

    BECAUSE         shift and go to state 169
    .               shift and go to state 119
    ALICE           shift and go to state 122
    WHAT            shift and go to state 118
    ID              shift and go to state 137
    EVENTUALLY      shift and go to state 121
    EITHER          shift and go to state 128
    OPENED          shift and go to state 112
    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17
    PERHAPS         shift and go to state 117

    body                           shift and go to state 120
    conditionalStmt                shift and go to state 126
    expr                           shift and go to state 127
    stmt                           shift and go to state 136

state 156

    (27) stmt -> expr ATE terminator .

    OR              reduce using rule 27 (stmt -> expr ATE terminator .)
    .               reduce using rule 27 (stmt -> expr ATE terminator .)
    ALICE           reduce using rule 27 (stmt -> expr ATE terminator .)
    WHAT            reduce using rule 27 (stmt -> expr ATE terminator .)
    ID              reduce using rule 27 (stmt -> expr ATE terminator .)
    EVENTUALLY      reduce using rule 27 (stmt -> expr ATE terminator .)
    EITHER          reduce using rule 27 (stmt -> expr ATE terminator .)
    OPENED          reduce using rule 27 (stmt -> expr ATE terminator .)
    LOGICAL_NOT     reduce using rule 27 (stmt -> expr ATE terminator .)
    ~               reduce using rule 27 (stmt -> expr ATE terminator .)
    +               reduce using rule 27 (stmt -> expr ATE terminator .)
    -               reduce using rule 27 (stmt -> expr ATE terminator .)
    STRING_LITERAL  reduce using rule 27 (stmt -> expr ATE terminator .)
    CHAR_LITERAL    reduce using rule 27 (stmt -> expr ATE terminator .)
    INT_LITERAL     reduce using rule 27 (stmt -> expr ATE terminator .)
    (               reduce using rule 27 (stmt -> expr ATE terminator .)
    PERHAPS         reduce using rule 27 (stmt -> expr ATE terminator .)
    ENOUGH          reduce using rule 27 (stmt -> expr ATE terminator .)
    CLOSED          reduce using rule 27 (stmt -> expr ATE terminator .)
    BECAUSE         reduce using rule 27 (stmt -> expr ATE terminator .)


state 157

    (30) stmt -> expr SPOKE terminator .

    OR              reduce using rule 30 (stmt -> expr SPOKE terminator .)
    .               reduce using rule 30 (stmt -> expr SPOKE terminator .)
    ALICE           reduce using rule 30 (stmt -> expr SPOKE terminator .)
    WHAT            reduce using rule 30 (stmt -> expr SPOKE terminator .)
    ID              reduce using rule 30 (stmt -> expr SPOKE terminator .)
    EVENTUALLY      reduce using rule 30 (stmt -> expr SPOKE terminator .)
    EITHER          reduce using rule 30 (stmt -> expr SPOKE terminator .)
    OPENED          reduce using rule 30 (stmt -> expr SPOKE terminator .)
    LOGICAL_NOT     reduce using rule 30 (stmt -> expr SPOKE terminator .)
    ~               reduce using rule 30 (stmt -> expr SPOKE terminator .)
    +               reduce using rule 30 (stmt -> expr SPOKE terminator .)
    -               reduce using rule 30 (stmt -> expr SPOKE terminator .)
    STRING_LITERAL  reduce using rule 30 (stmt -> expr SPOKE terminator .)
    CHAR_LITERAL    reduce using rule 30 (stmt -> expr SPOKE terminator .)
    INT_LITERAL     reduce using rule 30 (stmt -> expr SPOKE terminator .)
    (               reduce using rule 30 (stmt -> expr SPOKE terminator .)
    PERHAPS         reduce using rule 30 (stmt -> expr SPOKE terminator .)
    ENOUGH          reduce using rule 30 (stmt -> expr SPOKE terminator .)
    CLOSED          reduce using rule 30 (stmt -> expr SPOKE terminator .)
    BECAUSE         reduce using rule 30 (stmt -> expr SPOKE terminator .)


state 158

    (28) stmt -> expr DRANK terminator .

    OR              reduce using rule 28 (stmt -> expr DRANK terminator .)
    .               reduce using rule 28 (stmt -> expr DRANK terminator .)
    ALICE           reduce using rule 28 (stmt -> expr DRANK terminator .)
    WHAT            reduce using rule 28 (stmt -> expr DRANK terminator .)
    ID              reduce using rule 28 (stmt -> expr DRANK terminator .)
    EVENTUALLY      reduce using rule 28 (stmt -> expr DRANK terminator .)
    EITHER          reduce using rule 28 (stmt -> expr DRANK terminator .)
    OPENED          reduce using rule 28 (stmt -> expr DRANK terminator .)
    LOGICAL_NOT     reduce using rule 28 (stmt -> expr DRANK terminator .)
    ~               reduce using rule 28 (stmt -> expr DRANK terminator .)
    +               reduce using rule 28 (stmt -> expr DRANK terminator .)
    -               reduce using rule 28 (stmt -> expr DRANK terminator .)
    STRING_LITERAL  reduce using rule 28 (stmt -> expr DRANK terminator .)
    CHAR_LITERAL    reduce using rule 28 (stmt -> expr DRANK terminator .)
    INT_LITERAL     reduce using rule 28 (stmt -> expr DRANK terminator .)
    (               reduce using rule 28 (stmt -> expr DRANK terminator .)
    PERHAPS         reduce using rule 28 (stmt -> expr DRANK terminator .)
    ENOUGH          reduce using rule 28 (stmt -> expr DRANK terminator .)
    CLOSED          reduce using rule 28 (stmt -> expr DRANK terminator .)
    BECAUSE         reduce using rule 28 (stmt -> expr DRANK terminator .)


state 159

    (31) stmt -> expr SAID ALICE . terminator
    (75) terminator -> . .
    (76) terminator -> . ,
    (77) terminator -> . AND
    (78) terminator -> . BUT
    (79) terminator -> . THEN

    .               shift and go to state 73
    ,               shift and go to state 69
    AND             shift and go to state 67
    BUT             shift and go to state 70
    THEN            shift and go to state 68

    terminator                     shift and go to state 170

state 160

    (26) stmt -> expr BECAME expr . terminator
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr
    (75) terminator -> . .
    (76) terminator -> . ,
    (77) terminator -> . AND
    (78) terminator -> . BUT
    (79) terminator -> . THEN

    +               shift and go to state 48
    -               shift and go to state 50
    *               shift and go to state 49
    /               shift and go to state 51
    %               shift and go to state 45
    &               shift and go to state 47
    |               shift and go to state 57
    ^               shift and go to state 55
    LOGICAL_OR      shift and go to state 56
    LOGICAL_AND     shift and go to state 42
    GREATER_THAN    shift and go to state 41
    LESS_THAN       shift and go to state 43
    GREATER_EQUAL   shift and go to state 46
    LESS_EQUAL      shift and go to state 54
    EQUAL           shift and go to state 53
    NOT_EQUAL       shift and go to state 44
    .               shift and go to state 73
    ,               shift and go to state 69
    AND             shift and go to state 67
    BUT             shift and go to state 70
    THEN            shift and go to state 68

    terminator                     shift and go to state 171

state 161

    (35) stmt -> EITHER ( expr . ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    )               shift and go to state 172
    +               shift and go to state 48
    -               shift and go to state 50
    *               shift and go to state 49
    /               shift and go to state 51
    %               shift and go to state 45
    &               shift and go to state 47
    |               shift and go to state 57
    ^               shift and go to state 55
    LOGICAL_OR      shift and go to state 56
    LOGICAL_AND     shift and go to state 42
    GREATER_THAN    shift and go to state 41
    LESS_THAN       shift and go to state 43
    GREATER_EQUAL   shift and go to state 46
    LESS_EQUAL      shift and go to state 54
    EQUAL           shift and go to state 53
    NOT_EQUAL       shift and go to state 44


state 162

    (19) body -> OPENED decls compoundStmt CLOSED .

    ID              reduce using rule 19 (body -> OPENED decls compoundStmt CLOSED .)
    THE             reduce using rule 19 (body -> OPENED decls compoundStmt CLOSED .)
    $end            reduce using rule 19 (body -> OPENED decls compoundStmt CLOSED .)
    .               reduce using rule 19 (body -> OPENED decls compoundStmt CLOSED .)
    ALICE           reduce using rule 19 (body -> OPENED decls compoundStmt CLOSED .)
    WHAT            reduce using rule 19 (body -> OPENED decls compoundStmt CLOSED .)
    EVENTUALLY      reduce using rule 19 (body -> OPENED decls compoundStmt CLOSED .)
    EITHER          reduce using rule 19 (body -> OPENED decls compoundStmt CLOSED .)
    OPENED          reduce using rule 19 (body -> OPENED decls compoundStmt CLOSED .)
    LOGICAL_NOT     reduce using rule 19 (body -> OPENED decls compoundStmt CLOSED .)
    ~               reduce using rule 19 (body -> OPENED decls compoundStmt CLOSED .)
    +               reduce using rule 19 (body -> OPENED decls compoundStmt CLOSED .)
    -               reduce using rule 19 (body -> OPENED decls compoundStmt CLOSED .)
    STRING_LITERAL  reduce using rule 19 (body -> OPENED decls compoundStmt CLOSED .)
    CHAR_LITERAL    reduce using rule 19 (body -> OPENED decls compoundStmt CLOSED .)
    INT_LITERAL     reduce using rule 19 (body -> OPENED decls compoundStmt CLOSED .)
    (               reduce using rule 19 (body -> OPENED decls compoundStmt CLOSED .)
    PERHAPS         reduce using rule 19 (body -> OPENED decls compoundStmt CLOSED .)
    BECAUSE         reduce using rule 19 (body -> OPENED decls compoundStmt CLOSED .)
    OR              reduce using rule 19 (body -> OPENED decls compoundStmt CLOSED .)
    CLOSED          reduce using rule 19 (body -> OPENED decls compoundStmt CLOSED .)
    ENOUGH          reduce using rule 19 (body -> OPENED decls compoundStmt CLOSED .)


state 163

    (38) conditionalStmt -> PERHAPS ( expr ) . SO compoundStmt

    SO              shift and go to state 173


state 164

    (32) stmt -> WHAT WAS expr ? .

    OR              reduce using rule 32 (stmt -> WHAT WAS expr ? .)
    .               reduce using rule 32 (stmt -> WHAT WAS expr ? .)
    ALICE           reduce using rule 32 (stmt -> WHAT WAS expr ? .)
    WHAT            reduce using rule 32 (stmt -> WHAT WAS expr ? .)
    ID              reduce using rule 32 (stmt -> WHAT WAS expr ? .)
    EVENTUALLY      reduce using rule 32 (stmt -> WHAT WAS expr ? .)
    EITHER          reduce using rule 32 (stmt -> WHAT WAS expr ? .)
    OPENED          reduce using rule 32 (stmt -> WHAT WAS expr ? .)
    LOGICAL_NOT     reduce using rule 32 (stmt -> WHAT WAS expr ? .)
    ~               reduce using rule 32 (stmt -> WHAT WAS expr ? .)
    +               reduce using rule 32 (stmt -> WHAT WAS expr ? .)
    -               reduce using rule 32 (stmt -> WHAT WAS expr ? .)
    STRING_LITERAL  reduce using rule 32 (stmt -> WHAT WAS expr ? .)
    CHAR_LITERAL    reduce using rule 32 (stmt -> WHAT WAS expr ? .)
    INT_LITERAL     reduce using rule 32 (stmt -> WHAT WAS expr ? .)
    (               reduce using rule 32 (stmt -> WHAT WAS expr ? .)
    PERHAPS         reduce using rule 32 (stmt -> WHAT WAS expr ? .)
    ENOUGH          reduce using rule 32 (stmt -> WHAT WAS expr ? .)
    CLOSED          reduce using rule 32 (stmt -> WHAT WAS expr ? .)
    BECAUSE         reduce using rule 32 (stmt -> WHAT WAS expr ? .)


state 165

    (34) stmt -> EVENTUALLY ( expr ) . BECAUSE compoundStmt ENOUGH TIMES

    BECAUSE         shift and go to state 174


state 166

    (29) stmt -> ALICE FOUND expr . .

    OR              reduce using rule 29 (stmt -> ALICE FOUND expr . .)
    .               reduce using rule 29 (stmt -> ALICE FOUND expr . .)
    ALICE           reduce using rule 29 (stmt -> ALICE FOUND expr . .)
    WHAT            reduce using rule 29 (stmt -> ALICE FOUND expr . .)
    ID              reduce using rule 29 (stmt -> ALICE FOUND expr . .)
    EVENTUALLY      reduce using rule 29 (stmt -> ALICE FOUND expr . .)
    EITHER          reduce using rule 29 (stmt -> ALICE FOUND expr . .)
    OPENED          reduce using rule 29 (stmt -> ALICE FOUND expr . .)
    LOGICAL_NOT     reduce using rule 29 (stmt -> ALICE FOUND expr . .)
    ~               reduce using rule 29 (stmt -> ALICE FOUND expr . .)
    +               reduce using rule 29 (stmt -> ALICE FOUND expr . .)
    -               reduce using rule 29 (stmt -> ALICE FOUND expr . .)
    STRING_LITERAL  reduce using rule 29 (stmt -> ALICE FOUND expr . .)
    CHAR_LITERAL    reduce using rule 29 (stmt -> ALICE FOUND expr . .)
    INT_LITERAL     reduce using rule 29 (stmt -> ALICE FOUND expr . .)
    (               reduce using rule 29 (stmt -> ALICE FOUND expr . .)
    PERHAPS         reduce using rule 29 (stmt -> ALICE FOUND expr . .)
    ENOUGH          reduce using rule 29 (stmt -> ALICE FOUND expr . .)
    CLOSED          reduce using rule 29 (stmt -> ALICE FOUND expr . .)
    BECAUSE         reduce using rule 29 (stmt -> ALICE FOUND expr . .)


state 167

    (36) stmt -> conditionalStmt BECAUSE ALICE WAS . UNSURE WHICH

    UNSURE          shift and go to state 175


state 168

    (39) conditionalStmt -> conditionalStmt OR MAYBE ( . expr ) SO compoundStmt
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams

    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    ID              shift and go to state 20
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17

    expr                           shift and go to state 176

state 169

    (37) stmt -> conditionalStmt OR compoundStmt BECAUSE . ALICE WAS UNSURE WHICH

    ALICE           shift and go to state 177


state 170

    (31) stmt -> expr SAID ALICE terminator .

    OR              reduce using rule 31 (stmt -> expr SAID ALICE terminator .)
    .               reduce using rule 31 (stmt -> expr SAID ALICE terminator .)
    ALICE           reduce using rule 31 (stmt -> expr SAID ALICE terminator .)
    WHAT            reduce using rule 31 (stmt -> expr SAID ALICE terminator .)
    ID              reduce using rule 31 (stmt -> expr SAID ALICE terminator .)
    EVENTUALLY      reduce using rule 31 (stmt -> expr SAID ALICE terminator .)
    EITHER          reduce using rule 31 (stmt -> expr SAID ALICE terminator .)
    OPENED          reduce using rule 31 (stmt -> expr SAID ALICE terminator .)
    LOGICAL_NOT     reduce using rule 31 (stmt -> expr SAID ALICE terminator .)
    ~               reduce using rule 31 (stmt -> expr SAID ALICE terminator .)
    +               reduce using rule 31 (stmt -> expr SAID ALICE terminator .)
    -               reduce using rule 31 (stmt -> expr SAID ALICE terminator .)
    STRING_LITERAL  reduce using rule 31 (stmt -> expr SAID ALICE terminator .)
    CHAR_LITERAL    reduce using rule 31 (stmt -> expr SAID ALICE terminator .)
    INT_LITERAL     reduce using rule 31 (stmt -> expr SAID ALICE terminator .)
    (               reduce using rule 31 (stmt -> expr SAID ALICE terminator .)
    PERHAPS         reduce using rule 31 (stmt -> expr SAID ALICE terminator .)
    ENOUGH          reduce using rule 31 (stmt -> expr SAID ALICE terminator .)
    CLOSED          reduce using rule 31 (stmt -> expr SAID ALICE terminator .)
    BECAUSE         reduce using rule 31 (stmt -> expr SAID ALICE terminator .)


state 171

    (26) stmt -> expr BECAME expr terminator .

    OR              reduce using rule 26 (stmt -> expr BECAME expr terminator .)
    .               reduce using rule 26 (stmt -> expr BECAME expr terminator .)
    ALICE           reduce using rule 26 (stmt -> expr BECAME expr terminator .)
    WHAT            reduce using rule 26 (stmt -> expr BECAME expr terminator .)
    ID              reduce using rule 26 (stmt -> expr BECAME expr terminator .)
    EVENTUALLY      reduce using rule 26 (stmt -> expr BECAME expr terminator .)
    EITHER          reduce using rule 26 (stmt -> expr BECAME expr terminator .)
    OPENED          reduce using rule 26 (stmt -> expr BECAME expr terminator .)
    LOGICAL_NOT     reduce using rule 26 (stmt -> expr BECAME expr terminator .)
    ~               reduce using rule 26 (stmt -> expr BECAME expr terminator .)
    +               reduce using rule 26 (stmt -> expr BECAME expr terminator .)
    -               reduce using rule 26 (stmt -> expr BECAME expr terminator .)
    STRING_LITERAL  reduce using rule 26 (stmt -> expr BECAME expr terminator .)
    CHAR_LITERAL    reduce using rule 26 (stmt -> expr BECAME expr terminator .)
    INT_LITERAL     reduce using rule 26 (stmt -> expr BECAME expr terminator .)
    (               reduce using rule 26 (stmt -> expr BECAME expr terminator .)
    PERHAPS         reduce using rule 26 (stmt -> expr BECAME expr terminator .)
    ENOUGH          reduce using rule 26 (stmt -> expr BECAME expr terminator .)
    CLOSED          reduce using rule 26 (stmt -> expr BECAME expr terminator .)
    BECAUSE         reduce using rule 26 (stmt -> expr BECAME expr terminator .)


state 172

    (35) stmt -> EITHER ( expr ) . SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH

    SO              shift and go to state 178


state 173

    (38) conditionalStmt -> PERHAPS ( expr ) SO . compoundStmt
    (22) compoundStmt -> . compoundStmt stmt
    (23) compoundStmt -> . stmt
    (24) stmt -> . body
    (25) stmt -> . .
    (26) stmt -> . expr BECAME expr terminator
    (27) stmt -> . expr ATE terminator
    (28) stmt -> . expr DRANK terminator
    (29) stmt -> . ALICE FOUND expr .
    (30) stmt -> . expr SPOKE terminator
    (31) stmt -> . expr SAID ALICE terminator
    (32) stmt -> . WHAT WAS expr ?
    (33) stmt -> . ID actualParams terminator
    (34) stmt -> . EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES
    (35) stmt -> . EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (36) stmt -> . conditionalStmt BECAUSE ALICE WAS UNSURE WHICH
    (37) stmt -> . conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (19) body -> . OPENED decls compoundStmt CLOSED
    (20) body -> . OPENED compoundStmt CLOSED
    (21) body -> . OPENED CLOSED
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams
    (38) conditionalStmt -> . PERHAPS ( expr ) SO compoundStmt
    (39) conditionalStmt -> . conditionalStmt OR MAYBE ( expr ) SO compoundStmt

    .               shift and go to state 119
    ALICE           shift and go to state 122
    WHAT            shift and go to state 118
    ID              shift and go to state 137
    EVENTUALLY      shift and go to state 121
    EITHER          shift and go to state 128
    OPENED          shift and go to state 112
    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17
    PERHAPS         shift and go to state 117

    body                           shift and go to state 120
    conditionalStmt                shift and go to state 126
    expr                           shift and go to state 127
    stmt                           shift and go to state 123
    compoundStmt                   shift and go to state 179

state 174

    (34) stmt -> EVENTUALLY ( expr ) BECAUSE . compoundStmt ENOUGH TIMES
    (22) compoundStmt -> . compoundStmt stmt
    (23) compoundStmt -> . stmt
    (24) stmt -> . body
    (25) stmt -> . .
    (26) stmt -> . expr BECAME expr terminator
    (27) stmt -> . expr ATE terminator
    (28) stmt -> . expr DRANK terminator
    (29) stmt -> . ALICE FOUND expr .
    (30) stmt -> . expr SPOKE terminator
    (31) stmt -> . expr SAID ALICE terminator
    (32) stmt -> . WHAT WAS expr ?
    (33) stmt -> . ID actualParams terminator
    (34) stmt -> . EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES
    (35) stmt -> . EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (36) stmt -> . conditionalStmt BECAUSE ALICE WAS UNSURE WHICH
    (37) stmt -> . conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (19) body -> . OPENED decls compoundStmt CLOSED
    (20) body -> . OPENED compoundStmt CLOSED
    (21) body -> . OPENED CLOSED
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams
    (38) conditionalStmt -> . PERHAPS ( expr ) SO compoundStmt
    (39) conditionalStmt -> . conditionalStmt OR MAYBE ( expr ) SO compoundStmt

    .               shift and go to state 119
    ALICE           shift and go to state 122
    WHAT            shift and go to state 118
    ID              shift and go to state 137
    EVENTUALLY      shift and go to state 121
    EITHER          shift and go to state 128
    OPENED          shift and go to state 112
    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17
    PERHAPS         shift and go to state 117

    body                           shift and go to state 120
    conditionalStmt                shift and go to state 126
    expr                           shift and go to state 127
    stmt                           shift and go to state 123
    compoundStmt                   shift and go to state 180

state 175

    (36) stmt -> conditionalStmt BECAUSE ALICE WAS UNSURE . WHICH

    WHICH           shift and go to state 181


state 176

    (39) conditionalStmt -> conditionalStmt OR MAYBE ( expr . ) SO compoundStmt
    (44) expr -> expr . + expr
    (45) expr -> expr . - expr
    (46) expr -> expr . * expr
    (47) expr -> expr . / expr
    (48) expr -> expr . % expr
    (49) expr -> expr . & expr
    (50) expr -> expr . | expr
    (51) expr -> expr . ^ expr
    (52) expr -> expr . LOGICAL_OR expr
    (53) expr -> expr . LOGICAL_AND expr
    (54) expr -> expr . GREATER_THAN expr
    (55) expr -> expr . LESS_THAN expr
    (56) expr -> expr . GREATER_EQUAL expr
    (57) expr -> expr . LESS_EQUAL expr
    (58) expr -> expr . EQUAL expr
    (59) expr -> expr . NOT_EQUAL expr

    )               shift and go to state 182
    +               shift and go to state 48
    -               shift and go to state 50
    *               shift and go to state 49
    /               shift and go to state 51
    %               shift and go to state 45
    &               shift and go to state 47
    |               shift and go to state 57
    ^               shift and go to state 55
    LOGICAL_OR      shift and go to state 56
    LOGICAL_AND     shift and go to state 42
    GREATER_THAN    shift and go to state 41
    LESS_THAN       shift and go to state 43
    GREATER_EQUAL   shift and go to state 46
    LESS_EQUAL      shift and go to state 54
    EQUAL           shift and go to state 53
    NOT_EQUAL       shift and go to state 44


state 177

    (37) stmt -> conditionalStmt OR compoundStmt BECAUSE ALICE . WAS UNSURE WHICH

    WAS             shift and go to state 183


state 178

    (35) stmt -> EITHER ( expr ) SO . compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (22) compoundStmt -> . compoundStmt stmt
    (23) compoundStmt -> . stmt
    (24) stmt -> . body
    (25) stmt -> . .
    (26) stmt -> . expr BECAME expr terminator
    (27) stmt -> . expr ATE terminator
    (28) stmt -> . expr DRANK terminator
    (29) stmt -> . ALICE FOUND expr .
    (30) stmt -> . expr SPOKE terminator
    (31) stmt -> . expr SAID ALICE terminator
    (32) stmt -> . WHAT WAS expr ?
    (33) stmt -> . ID actualParams terminator
    (34) stmt -> . EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES
    (35) stmt -> . EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (36) stmt -> . conditionalStmt BECAUSE ALICE WAS UNSURE WHICH
    (37) stmt -> . conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (19) body -> . OPENED decls compoundStmt CLOSED
    (20) body -> . OPENED compoundStmt CLOSED
    (21) body -> . OPENED CLOSED
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams
    (38) conditionalStmt -> . PERHAPS ( expr ) SO compoundStmt
    (39) conditionalStmt -> . conditionalStmt OR MAYBE ( expr ) SO compoundStmt

    .               shift and go to state 119
    ALICE           shift and go to state 122
    WHAT            shift and go to state 118
    ID              shift and go to state 137
    EVENTUALLY      shift and go to state 121
    EITHER          shift and go to state 128
    OPENED          shift and go to state 112
    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17
    PERHAPS         shift and go to state 117

    body                           shift and go to state 120
    conditionalStmt                shift and go to state 126
    expr                           shift and go to state 127
    stmt                           shift and go to state 123
    compoundStmt                   shift and go to state 184

state 179

    (38) conditionalStmt -> PERHAPS ( expr ) SO compoundStmt .
    (22) compoundStmt -> compoundStmt . stmt
    (24) stmt -> . body
    (25) stmt -> . .
    (26) stmt -> . expr BECAME expr terminator
    (27) stmt -> . expr ATE terminator
    (28) stmt -> . expr DRANK terminator
    (29) stmt -> . ALICE FOUND expr .
    (30) stmt -> . expr SPOKE terminator
    (31) stmt -> . expr SAID ALICE terminator
    (32) stmt -> . WHAT WAS expr ?
    (33) stmt -> . ID actualParams terminator
    (34) stmt -> . EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES
    (35) stmt -> . EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (36) stmt -> . conditionalStmt BECAUSE ALICE WAS UNSURE WHICH
    (37) stmt -> . conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (19) body -> . OPENED decls compoundStmt CLOSED
    (20) body -> . OPENED compoundStmt CLOSED
    (21) body -> . OPENED CLOSED
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams
    (38) conditionalStmt -> . PERHAPS ( expr ) SO compoundStmt
    (39) conditionalStmt -> . conditionalStmt OR MAYBE ( expr ) SO compoundStmt

    BECAUSE         reduce using rule 38 (conditionalStmt -> PERHAPS ( expr ) SO compoundStmt .)
    OR              reduce using rule 38 (conditionalStmt -> PERHAPS ( expr ) SO compoundStmt .)
    .               shift and go to state 119
    ALICE           shift and go to state 122
    WHAT            shift and go to state 118
    ID              shift and go to state 137
    EVENTUALLY      shift and go to state 121
    EITHER          shift and go to state 128
    OPENED          shift and go to state 112
    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17
    PERHAPS         shift and go to state 117

    body                           shift and go to state 120
    conditionalStmt                shift and go to state 126
    expr                           shift and go to state 127
    stmt                           shift and go to state 136

state 180

    (34) stmt -> EVENTUALLY ( expr ) BECAUSE compoundStmt . ENOUGH TIMES
    (22) compoundStmt -> compoundStmt . stmt
    (24) stmt -> . body
    (25) stmt -> . .
    (26) stmt -> . expr BECAME expr terminator
    (27) stmt -> . expr ATE terminator
    (28) stmt -> . expr DRANK terminator
    (29) stmt -> . ALICE FOUND expr .
    (30) stmt -> . expr SPOKE terminator
    (31) stmt -> . expr SAID ALICE terminator
    (32) stmt -> . WHAT WAS expr ?
    (33) stmt -> . ID actualParams terminator
    (34) stmt -> . EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES
    (35) stmt -> . EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (36) stmt -> . conditionalStmt BECAUSE ALICE WAS UNSURE WHICH
    (37) stmt -> . conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (19) body -> . OPENED decls compoundStmt CLOSED
    (20) body -> . OPENED compoundStmt CLOSED
    (21) body -> . OPENED CLOSED
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams
    (38) conditionalStmt -> . PERHAPS ( expr ) SO compoundStmt
    (39) conditionalStmt -> . conditionalStmt OR MAYBE ( expr ) SO compoundStmt

    ENOUGH          shift and go to state 185
    .               shift and go to state 119
    ALICE           shift and go to state 122
    WHAT            shift and go to state 118
    ID              shift and go to state 137
    EVENTUALLY      shift and go to state 121
    EITHER          shift and go to state 128
    OPENED          shift and go to state 112
    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17
    PERHAPS         shift and go to state 117

    body                           shift and go to state 120
    conditionalStmt                shift and go to state 126
    expr                           shift and go to state 127
    stmt                           shift and go to state 136

state 181

    (36) stmt -> conditionalStmt BECAUSE ALICE WAS UNSURE WHICH .

    OR              reduce using rule 36 (stmt -> conditionalStmt BECAUSE ALICE WAS UNSURE WHICH .)
    .               reduce using rule 36 (stmt -> conditionalStmt BECAUSE ALICE WAS UNSURE WHICH .)
    ALICE           reduce using rule 36 (stmt -> conditionalStmt BECAUSE ALICE WAS UNSURE WHICH .)
    WHAT            reduce using rule 36 (stmt -> conditionalStmt BECAUSE ALICE WAS UNSURE WHICH .)
    ID              reduce using rule 36 (stmt -> conditionalStmt BECAUSE ALICE WAS UNSURE WHICH .)
    EVENTUALLY      reduce using rule 36 (stmt -> conditionalStmt BECAUSE ALICE WAS UNSURE WHICH .)
    EITHER          reduce using rule 36 (stmt -> conditionalStmt BECAUSE ALICE WAS UNSURE WHICH .)
    OPENED          reduce using rule 36 (stmt -> conditionalStmt BECAUSE ALICE WAS UNSURE WHICH .)
    LOGICAL_NOT     reduce using rule 36 (stmt -> conditionalStmt BECAUSE ALICE WAS UNSURE WHICH .)
    ~               reduce using rule 36 (stmt -> conditionalStmt BECAUSE ALICE WAS UNSURE WHICH .)
    +               reduce using rule 36 (stmt -> conditionalStmt BECAUSE ALICE WAS UNSURE WHICH .)
    -               reduce using rule 36 (stmt -> conditionalStmt BECAUSE ALICE WAS UNSURE WHICH .)
    STRING_LITERAL  reduce using rule 36 (stmt -> conditionalStmt BECAUSE ALICE WAS UNSURE WHICH .)
    CHAR_LITERAL    reduce using rule 36 (stmt -> conditionalStmt BECAUSE ALICE WAS UNSURE WHICH .)
    INT_LITERAL     reduce using rule 36 (stmt -> conditionalStmt BECAUSE ALICE WAS UNSURE WHICH .)
    (               reduce using rule 36 (stmt -> conditionalStmt BECAUSE ALICE WAS UNSURE WHICH .)
    PERHAPS         reduce using rule 36 (stmt -> conditionalStmt BECAUSE ALICE WAS UNSURE WHICH .)
    ENOUGH          reduce using rule 36 (stmt -> conditionalStmt BECAUSE ALICE WAS UNSURE WHICH .)
    CLOSED          reduce using rule 36 (stmt -> conditionalStmt BECAUSE ALICE WAS UNSURE WHICH .)
    BECAUSE         reduce using rule 36 (stmt -> conditionalStmt BECAUSE ALICE WAS UNSURE WHICH .)


state 182

    (39) conditionalStmt -> conditionalStmt OR MAYBE ( expr ) . SO compoundStmt

    SO              shift and go to state 186


state 183

    (37) stmt -> conditionalStmt OR compoundStmt BECAUSE ALICE WAS . UNSURE WHICH

    UNSURE          shift and go to state 187


state 184

    (35) stmt -> EITHER ( expr ) SO compoundStmt . OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (22) compoundStmt -> compoundStmt . stmt
    (24) stmt -> . body
    (25) stmt -> . .
    (26) stmt -> . expr BECAME expr terminator
    (27) stmt -> . expr ATE terminator
    (28) stmt -> . expr DRANK terminator
    (29) stmt -> . ALICE FOUND expr .
    (30) stmt -> . expr SPOKE terminator
    (31) stmt -> . expr SAID ALICE terminator
    (32) stmt -> . WHAT WAS expr ?
    (33) stmt -> . ID actualParams terminator
    (34) stmt -> . EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES
    (35) stmt -> . EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (36) stmt -> . conditionalStmt BECAUSE ALICE WAS UNSURE WHICH
    (37) stmt -> . conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (19) body -> . OPENED decls compoundStmt CLOSED
    (20) body -> . OPENED compoundStmt CLOSED
    (21) body -> . OPENED CLOSED
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams
    (38) conditionalStmt -> . PERHAPS ( expr ) SO compoundStmt
    (39) conditionalStmt -> . conditionalStmt OR MAYBE ( expr ) SO compoundStmt

    OR              shift and go to state 188
    .               shift and go to state 119
    ALICE           shift and go to state 122
    WHAT            shift and go to state 118
    ID              shift and go to state 137
    EVENTUALLY      shift and go to state 121
    EITHER          shift and go to state 128
    OPENED          shift and go to state 112
    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17
    PERHAPS         shift and go to state 117

    body                           shift and go to state 120
    conditionalStmt                shift and go to state 126
    expr                           shift and go to state 127
    stmt                           shift and go to state 136

state 185

    (34) stmt -> EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH . TIMES

    TIMES           shift and go to state 189


state 186

    (39) conditionalStmt -> conditionalStmt OR MAYBE ( expr ) SO . compoundStmt
    (22) compoundStmt -> . compoundStmt stmt
    (23) compoundStmt -> . stmt
    (24) stmt -> . body
    (25) stmt -> . .
    (26) stmt -> . expr BECAME expr terminator
    (27) stmt -> . expr ATE terminator
    (28) stmt -> . expr DRANK terminator
    (29) stmt -> . ALICE FOUND expr .
    (30) stmt -> . expr SPOKE terminator
    (31) stmt -> . expr SAID ALICE terminator
    (32) stmt -> . WHAT WAS expr ?
    (33) stmt -> . ID actualParams terminator
    (34) stmt -> . EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES
    (35) stmt -> . EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (36) stmt -> . conditionalStmt BECAUSE ALICE WAS UNSURE WHICH
    (37) stmt -> . conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (19) body -> . OPENED decls compoundStmt CLOSED
    (20) body -> . OPENED compoundStmt CLOSED
    (21) body -> . OPENED CLOSED
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams
    (38) conditionalStmt -> . PERHAPS ( expr ) SO compoundStmt
    (39) conditionalStmt -> . conditionalStmt OR MAYBE ( expr ) SO compoundStmt

    .               shift and go to state 119
    ALICE           shift and go to state 122
    WHAT            shift and go to state 118
    ID              shift and go to state 137
    EVENTUALLY      shift and go to state 121
    EITHER          shift and go to state 128
    OPENED          shift and go to state 112
    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17
    PERHAPS         shift and go to state 117

    body                           shift and go to state 120
    conditionalStmt                shift and go to state 126
    expr                           shift and go to state 127
    stmt                           shift and go to state 123
    compoundStmt                   shift and go to state 190

state 187

    (37) stmt -> conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE . WHICH

    WHICH           shift and go to state 191


state 188

    (35) stmt -> EITHER ( expr ) SO compoundStmt OR . compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (22) compoundStmt -> . compoundStmt stmt
    (23) compoundStmt -> . stmt
    (24) stmt -> . body
    (25) stmt -> . .
    (26) stmt -> . expr BECAME expr terminator
    (27) stmt -> . expr ATE terminator
    (28) stmt -> . expr DRANK terminator
    (29) stmt -> . ALICE FOUND expr .
    (30) stmt -> . expr SPOKE terminator
    (31) stmt -> . expr SAID ALICE terminator
    (32) stmt -> . WHAT WAS expr ?
    (33) stmt -> . ID actualParams terminator
    (34) stmt -> . EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES
    (35) stmt -> . EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (36) stmt -> . conditionalStmt BECAUSE ALICE WAS UNSURE WHICH
    (37) stmt -> . conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (19) body -> . OPENED decls compoundStmt CLOSED
    (20) body -> . OPENED compoundStmt CLOSED
    (21) body -> . OPENED CLOSED
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams
    (38) conditionalStmt -> . PERHAPS ( expr ) SO compoundStmt
    (39) conditionalStmt -> . conditionalStmt OR MAYBE ( expr ) SO compoundStmt

    .               shift and go to state 119
    ALICE           shift and go to state 122
    WHAT            shift and go to state 118
    ID              shift and go to state 137
    EVENTUALLY      shift and go to state 121
    EITHER          shift and go to state 128
    OPENED          shift and go to state 112
    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17
    PERHAPS         shift and go to state 117

    body                           shift and go to state 120
    conditionalStmt                shift and go to state 126
    expr                           shift and go to state 127
    stmt                           shift and go to state 123
    compoundStmt                   shift and go to state 192

state 189

    (34) stmt -> EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES .

    OR              reduce using rule 34 (stmt -> EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES .)
    .               reduce using rule 34 (stmt -> EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES .)
    ALICE           reduce using rule 34 (stmt -> EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES .)
    WHAT            reduce using rule 34 (stmt -> EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES .)
    ID              reduce using rule 34 (stmt -> EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES .)
    EVENTUALLY      reduce using rule 34 (stmt -> EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES .)
    EITHER          reduce using rule 34 (stmt -> EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES .)
    OPENED          reduce using rule 34 (stmt -> EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES .)
    LOGICAL_NOT     reduce using rule 34 (stmt -> EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES .)
    ~               reduce using rule 34 (stmt -> EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES .)
    +               reduce using rule 34 (stmt -> EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES .)
    -               reduce using rule 34 (stmt -> EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES .)
    STRING_LITERAL  reduce using rule 34 (stmt -> EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES .)
    CHAR_LITERAL    reduce using rule 34 (stmt -> EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES .)
    INT_LITERAL     reduce using rule 34 (stmt -> EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES .)
    (               reduce using rule 34 (stmt -> EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES .)
    PERHAPS         reduce using rule 34 (stmt -> EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES .)
    ENOUGH          reduce using rule 34 (stmt -> EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES .)
    CLOSED          reduce using rule 34 (stmt -> EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES .)
    BECAUSE         reduce using rule 34 (stmt -> EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES .)


state 190

    (39) conditionalStmt -> conditionalStmt OR MAYBE ( expr ) SO compoundStmt .
    (22) compoundStmt -> compoundStmt . stmt
    (24) stmt -> . body
    (25) stmt -> . .
    (26) stmt -> . expr BECAME expr terminator
    (27) stmt -> . expr ATE terminator
    (28) stmt -> . expr DRANK terminator
    (29) stmt -> . ALICE FOUND expr .
    (30) stmt -> . expr SPOKE terminator
    (31) stmt -> . expr SAID ALICE terminator
    (32) stmt -> . WHAT WAS expr ?
    (33) stmt -> . ID actualParams terminator
    (34) stmt -> . EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES
    (35) stmt -> . EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (36) stmt -> . conditionalStmt BECAUSE ALICE WAS UNSURE WHICH
    (37) stmt -> . conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (19) body -> . OPENED decls compoundStmt CLOSED
    (20) body -> . OPENED compoundStmt CLOSED
    (21) body -> . OPENED CLOSED
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams
    (38) conditionalStmt -> . PERHAPS ( expr ) SO compoundStmt
    (39) conditionalStmt -> . conditionalStmt OR MAYBE ( expr ) SO compoundStmt

    BECAUSE         reduce using rule 39 (conditionalStmt -> conditionalStmt OR MAYBE ( expr ) SO compoundStmt .)
    OR              reduce using rule 39 (conditionalStmt -> conditionalStmt OR MAYBE ( expr ) SO compoundStmt .)
    .               shift and go to state 119
    ALICE           shift and go to state 122
    WHAT            shift and go to state 118
    ID              shift and go to state 137
    EVENTUALLY      shift and go to state 121
    EITHER          shift and go to state 128
    OPENED          shift and go to state 112
    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17
    PERHAPS         shift and go to state 117

    body                           shift and go to state 120
    conditionalStmt                shift and go to state 126
    expr                           shift and go to state 127
    stmt                           shift and go to state 136

state 191

    (37) stmt -> conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .

    OR              reduce using rule 37 (stmt -> conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    .               reduce using rule 37 (stmt -> conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    ALICE           reduce using rule 37 (stmt -> conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    WHAT            reduce using rule 37 (stmt -> conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    ID              reduce using rule 37 (stmt -> conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    EVENTUALLY      reduce using rule 37 (stmt -> conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    EITHER          reduce using rule 37 (stmt -> conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    OPENED          reduce using rule 37 (stmt -> conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    LOGICAL_NOT     reduce using rule 37 (stmt -> conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    ~               reduce using rule 37 (stmt -> conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    +               reduce using rule 37 (stmt -> conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    -               reduce using rule 37 (stmt -> conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    STRING_LITERAL  reduce using rule 37 (stmt -> conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    CHAR_LITERAL    reduce using rule 37 (stmt -> conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    INT_LITERAL     reduce using rule 37 (stmt -> conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    (               reduce using rule 37 (stmt -> conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    PERHAPS         reduce using rule 37 (stmt -> conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    ENOUGH          reduce using rule 37 (stmt -> conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    CLOSED          reduce using rule 37 (stmt -> conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    BECAUSE         reduce using rule 37 (stmt -> conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)


state 192

    (35) stmt -> EITHER ( expr ) SO compoundStmt OR compoundStmt . BECAUSE ALICE WAS UNSURE WHICH
    (22) compoundStmt -> compoundStmt . stmt
    (24) stmt -> . body
    (25) stmt -> . .
    (26) stmt -> . expr BECAME expr terminator
    (27) stmt -> . expr ATE terminator
    (28) stmt -> . expr DRANK terminator
    (29) stmt -> . ALICE FOUND expr .
    (30) stmt -> . expr SPOKE terminator
    (31) stmt -> . expr SAID ALICE terminator
    (32) stmt -> . WHAT WAS expr ?
    (33) stmt -> . ID actualParams terminator
    (34) stmt -> . EVENTUALLY ( expr ) BECAUSE compoundStmt ENOUGH TIMES
    (35) stmt -> . EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (36) stmt -> . conditionalStmt BECAUSE ALICE WAS UNSURE WHICH
    (37) stmt -> . conditionalStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH
    (19) body -> . OPENED decls compoundStmt CLOSED
    (20) body -> . OPENED compoundStmt CLOSED
    (21) body -> . OPENED CLOSED
    (44) expr -> . expr + expr
    (45) expr -> . expr - expr
    (46) expr -> . expr * expr
    (47) expr -> . expr / expr
    (48) expr -> . expr % expr
    (49) expr -> . expr & expr
    (50) expr -> . expr | expr
    (51) expr -> . expr ^ expr
    (52) expr -> . expr LOGICAL_OR expr
    (53) expr -> . expr LOGICAL_AND expr
    (54) expr -> . expr GREATER_THAN expr
    (55) expr -> . expr LESS_THAN expr
    (56) expr -> . expr GREATER_EQUAL expr
    (57) expr -> . expr LESS_EQUAL expr
    (58) expr -> . expr EQUAL expr
    (59) expr -> . expr NOT_EQUAL expr
    (60) expr -> . LOGICAL_NOT expr
    (61) expr -> . ~ expr
    (62) expr -> . + expr
    (63) expr -> . - expr
    (64) expr -> . ID
    (65) expr -> . ID APOSTROPHE S expr PIECE
    (66) expr -> . STRING_LITERAL
    (67) expr -> . CHAR_LITERAL
    (68) expr -> . INT_LITERAL
    (69) expr -> . ( expr )
    (70) expr -> . ID actualParams
    (38) conditionalStmt -> . PERHAPS ( expr ) SO compoundStmt
    (39) conditionalStmt -> . conditionalStmt OR MAYBE ( expr ) SO compoundStmt

    BECAUSE         shift and go to state 193
    .               shift and go to state 119
    ALICE           shift and go to state 122
    WHAT            shift and go to state 118
    ID              shift and go to state 137
    EVENTUALLY      shift and go to state 121
    EITHER          shift and go to state 128
    OPENED          shift and go to state 112
    LOGICAL_NOT     shift and go to state 21
    ~               shift and go to state 26
    +               shift and go to state 18
    -               shift and go to state 19
    STRING_LITERAL  shift and go to state 22
    CHAR_LITERAL    shift and go to state 24
    INT_LITERAL     shift and go to state 25
    (               shift and go to state 17
    PERHAPS         shift and go to state 117

    body                           shift and go to state 120
    conditionalStmt                shift and go to state 126
    expr                           shift and go to state 127
    stmt                           shift and go to state 136

state 193

    (35) stmt -> EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE . ALICE WAS UNSURE WHICH

    ALICE           shift and go to state 194


state 194

    (35) stmt -> EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE . WAS UNSURE WHICH

    WAS             shift and go to state 195


state 195

    (35) stmt -> EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS . UNSURE WHICH

    UNSURE          shift and go to state 196


state 196

    (35) stmt -> EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE . WHICH

    WHICH           shift and go to state 197


state 197

    (35) stmt -> EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .

    OR              reduce using rule 35 (stmt -> EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    .               reduce using rule 35 (stmt -> EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    ALICE           reduce using rule 35 (stmt -> EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    WHAT            reduce using rule 35 (stmt -> EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    ID              reduce using rule 35 (stmt -> EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    EVENTUALLY      reduce using rule 35 (stmt -> EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    EITHER          reduce using rule 35 (stmt -> EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    OPENED          reduce using rule 35 (stmt -> EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    LOGICAL_NOT     reduce using rule 35 (stmt -> EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    ~               reduce using rule 35 (stmt -> EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    +               reduce using rule 35 (stmt -> EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    -               reduce using rule 35 (stmt -> EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    STRING_LITERAL  reduce using rule 35 (stmt -> EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    CHAR_LITERAL    reduce using rule 35 (stmt -> EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    INT_LITERAL     reduce using rule 35 (stmt -> EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    (               reduce using rule 35 (stmt -> EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    PERHAPS         reduce using rule 35 (stmt -> EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    ENOUGH          reduce using rule 35 (stmt -> EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    CLOSED          reduce using rule 35 (stmt -> EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)
    BECAUSE         reduce using rule 35 (stmt -> EITHER ( expr ) SO compoundStmt OR compoundStmt BECAUSE ALICE WAS UNSURE WHICH .)

